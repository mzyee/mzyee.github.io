<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL 如何准备开启一个表 | MZY&#39;s Blog</title>
<meta name="keywords" content="mysql, dictionary">
<meta name="description" content="MySQL 元信息管理及开表流程代码学习">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/mysql/meta/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b61814a257ce353cf79c7df04cbd11656e6b46cd9ff8eb7896ae9e46e264cce4.css" integrity="sha256-thgUolfONTz3nH3wTL0RZW5rRs2f&#43;Ot4lq6eRuJkzOQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="MySQL 如何准备开启一个表" />
<meta property="og:description" content="MySQL 元信息管理及开表流程代码学习" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/mysql/meta/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL 如何准备开启一个表"/>
<meta name="twitter:description" content="MySQL 元信息管理及开表流程代码学习"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL",
      "item": "https://mzyee.github.io/posts/mysql/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "MySQL 如何准备开启一个表",
      "item": "https://mzyee.github.io/posts/mysql/meta/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL 如何准备开启一个表",
  "name": "MySQL 如何准备开启一个表",
  "description": "MySQL 元信息管理及开表流程代码学习",
  "keywords": [
    "mysql", "dictionary"
  ],
  "articleBody": "1. 前言 大家都知道元数据（Metadata）是用来描述数据的数据，没有元数据的情况下我们就没办法理解、使用数据库中存储的数据。本文通过 InnoDB 开启一个表的流程来讨论 InnoDB 的元信息管理和相关开表流程代码。\n2. 元数据管理 2.1 元数据的物理存储 在 MySQL 8.0 之前，Server 层和存储引擎层会各自保留一份元数据（schema name，table definition 等），不仅在信息存储上有着重复冗余，而且可能存在两者之间存储的元数据不同步的现象。MySQL 在 8.0 中引入了 data dictionary 来进行 Server 层和不同引擎间统一的元数据管理，这些元数据都存储在 InnoDB 引擎的表中，Server 层和引擎层共享一份元数据，且支持原子性。\n这些元数据对应的 InnoDB 引擎表我们一般称为系统表，其表结构是固定的直接定义在代码类结构中（因此不再需要记录额外的元数据，要不然就套娃了），对应表文件在整个 MySQL 进行初始化时就建立了，有如 tables、columns、indexes、foreign_keys等系统表。可以通过下面的 SQL 在 debug 版本查看所有系统表：\n1 2 3 4 5 6 7 8 SET SESSION debug='+d,skip_dd_table_access_check'; SELECT id, name, schema_id, hidden FROM mysql.tables WHERE hidden='System' AND type='BASE TABLE'; 对于某张用户表来说，其元数据就是通过这些系统表对应的行内容记录构成，其逻辑关系可以近似看成是一颗树关联结构。其顶层入口是 table 表（mysql.tables）中的对应唯一记录，再通过记录的 table id 等索引项关联到如 columns、indexes 等各元数据系统表，进而获取这个表对应的元数据的记录内容。\n2.2 元数据的内存结构 在明确了 DD 元信息在物理层面的存储格式后，我们能够很清楚的知道，当需要构建一张用户表的元数据时，我们首先需要访问所有需要的系统表（元数据表），并依次在各系统表内找到对应这张用户表的相应记录，然后用这些元数据记录构建出用户表的内存对象。\n元数据表本身对应的内存对象结构是从 Object_table 类从派生出来的，有 Entity_object_table_impl 和 Object_table_impl 两大类。前者对应持久化有对应 Entity_object 的基本 DD 表，而后者对应着需要通过前者关联访问的 DD 表（不能直接被 create，search，drop）。两者再分别对应派生出 Tables、Tablespaces、… 和 Columns、Indexes、… 等具体内存结构体，一一对应各元数据系统表。注意一下，上面提到的这些内存对象是元数据表本身的内存对象，也就是访问元数据表所使用的内存对象，而非某一张用户表的内存对象。\n类似的，对于一张用户表，也是通过对应的元数据记录构建其内存对象结构。一般从 Entity_object_impl 类从派生出来的，像常用的 Table_impl 和 View_impl 分别表示用户表和视图对应元数据的内存对象。\n（当局部缓存穿透时）这些 objects 的操作逻辑被封装在 Storage_adapter 中，通过提供的 get() / drop() / store() 等接口，遍历查询或修改所有所需元数据表（btree 结构）中对应的 record，构建或持久性相应的 object 内存对象由/到引擎层。\n2.3 元数据的 cache 缓存 从上述操作中可以看出，直接从元数据表构建 DD object 内存对象是开销十分巨大的，过程中需要物理访问并索引多个 Btree 索引。因此 MySQL 建立了多层的 DD Cache 来就可能减小元数据的访问开销，一般称为元数据的 3 层缓存架构：\n每个 client 的独享缓存，即线程 THD 独占的 Dictionary_client 结构，其中有 committed、uncommitted、dropped 三类 objects map，最初 acquire 的 object 会被加入到committed map 中，client 调用 store 或 update 接口时将 object 放到 uncommitted map 中，然后在事务提交后将相应 objects 从 uncommitted map 移到 committed map 中，而调用 drop 接口会将 objects 加入 dropped map。当访问 Dictionary_client 穿透时，从 Shared_dictionary_cache 获取； Server 全局唯一的共享缓存，使用单例 Shared_dictionary_cache 来实现，其实质上也是 objects map 集合。在此缓存层相同 key 对应的 DD objects 对象唯一，这里的 key 其实就是对应元数据表的索引 key。当 Shared_dictionary_cache 穿透时，通过 Storage_adapter 从 InnoDB handler 读取元数据表记录。 存储引擎层（元数据表数据直接 BP 缓存），系统表的访问模式和普通用户表基本一致，注意采用的是 READ_COMMITTED 隔离级别。 3. 元数据的使用 3.1 Server 层元数据的使用 在前面实现 DD 元数据的管理后，MySQL 就能够通过使用元数据构建访问用户表的环境，这也就是我们常说的“开表”逻辑。前面我们已经介绍了元数据表本身的内存对象，通过访问元数据表相应记录，我们可以进一步构建用户表（或其他内容，如视图等）的内存对象。\n首先我们需要知晓 Server 层的两个关键结构体 TABLE_SHARE 和 TABLE:\n一张表被初次访问时，MySQL 会其建立一个 TABLE_SHARE 对象，与其与引擎层中的对应表 dict_table_t 相对应关联。TABLE_SHARE 是静态的，不能修改的，且一张表只存在一份，其中记录表定义相关的一些 DD 信息，如包含的字段等。TABLE_SHARE 只有在表结构被修改后才会删除，或者缓存使用满了会淘汰。简单的说，TABLE_SHARE 就是某张表定义的实体化对象。 对每一个会话，MySQL 会通过 TABLE_SHARE 会为查询中涉及的每个表建一个 TABLE 实体对象，这一过程叫表结构实例化。如果是 InnoDB 表还会创建 InnoDB 层的 handler，server 层会话通过 TABLE 对象经引擎层操作表文件实体。可以将 TABLE 对象看做表在 server 层的映射，将 handler 看做其为操作底层数据文件而在引擎层创建的句柄。 而“开表”逻辑就是通过访问元数据来获取 TABLE_SHARE 和构建 TABLE 实体对象的过程。我们具体看下 open_table 的代码逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 bool open_table(THD *thd, Table_ref *table_list, Open_table_context *ot_ctx) { // Step 0. 做一些前置检查... // Step 1. 除特殊 DD 表等场景，LOCK TABLES mode(LTM)下校验是否表对象都是 pre-opened 的； // Step 2. 非 LTM 模式（通常的模式），根据 mdl 请求模式获取 mdl 锁； if ((flags \u0026 (MYSQL_OPEN_HAS_MDL_LOCK | MYSQL_OPEN_SECONDARY_ENGINE)) == 0) { // 如果需要 write_lock mdl，还要获取 global read lock 保证正确冲突性 // ... if (open_table_get_mdl_lock(thd, ot_ctx, table_list, flags, \u0026mdl_ticket) || mdl_ticket == nullptr) { return true; } } else { /* caller 获取过 MDL 锁 */ mdl_ticket = table_list-\u003emdl_request.ticket; } // Step 3. 检查目标表的存在性； if (table_list-\u003eopen_strategy == Table_ref::OPEN_IF_EXISTS || table_list-\u003eopen_strategy == Table_ref::OPEN_FOR_CREATE) { bool exists; if (check_if_table_exists(thd, table_list, \u0026exists)) return true; /* 空读 */ if (!exists) { /* table 不存在于 DD，升级到 EXCLUSIVE MDL lock. */ if (table_list-\u003eopen_strategy == Table_ref::OPEN_FOR_CREATE \u0026\u0026 !(flags \u0026 (MYSQL_OPEN_FORCE_SHARED_MDL | MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL))) { MDL_deadlock_handler mdl_deadlock_handler(ot_ctx); thd-\u003epush_internal_handler(\u0026mdl_deadlock_handler); bool wait_result = thd-\u003emdl_context.upgrade_shared_lock( table_list-\u003emdl_request.ticket, MDL_EXCLUSIVE, thd-\u003evariables.lock_wait_timeout); thd-\u003epop_internal_handler(); /* Deadlock or timeout occurred while upgrading the lock. */ if (wait_result) return true; } return false; } } else if (table_list-\u003eopen_strategy == Table_ref::OPEN_STUB) /* 底层不真打开 */ return false; // Step 4. Table 存在，尝试开表，首先从 table_cache_manager 这个缓存找 retry_share : { Table_cache *tc = table_cache_manager.get_cache(thd); tc-\u003elock(); if (!table_list-\u003eis_view()) table = tc-\u003eget_table(thd, key, key_length, \u0026share); if (table) { /* Case 1. 找到未使用的 TABLE object */ if (!(flags \u0026 MYSQL_OPEN_IGNORE_FLUSH)) { /* 检查 DD 的版本是否过老或不一致 */ if (thd-\u003eopen_tables \u0026\u0026 thd-\u003eopen_tables-\u003es-\u003eversion() != share-\u003eversion()) { // 清理操作 ... return true; } } tc-\u003eunlock(); table-\u003efile-\u003erebind_psi(); table-\u003efile-\u003eha_extra(HA_EXTRA_RESET_STATE); thd-\u003estatus_var.table_open_cache_hits++; goto table_found; } else if (share) { /* Case 2. 无未使用 TABLE 对象，但是找到表的 TABLE_SHARE */ mysql_mutex_lock(\u0026LOCK_open); tc-\u003eunlock(); share-\u003eincrement_ref_count(); goto share_found; } else { /* Case 3. 无未使用 TABLE 对象，也无表的 TABLE_SHARE */ tc-\u003eunlock(); } } mysql_mutex_lock(\u0026LOCK_open); // Step 5. 获取 TABLE_SHARE： // 首先从 table_def_cache 缓存里找， // 穿透情况下确认 schema MDL 锁后建立新 TABLE_SHARE，并从元数据表读取记录填充。 if (!(share = get_table_share_with_discover( thd, table_list, key, key_length, flags \u0026 MYSQL_OPEN_SECONDARY_ENGINE, \u0026error))) { // 失败清理操作 ... return true; } if (table_list-\u003eis_view() || share-\u003eis_view) { /* 如果是 view 对象情况下的处理 */ // ... // return ... } share_found: if (!(flags \u0026 MYSQL_OPEN_IGNORE_FLUSH)) { if (share-\u003ehas_old_version()) { // 释放对 shard 的 reference，等待老版本 table share 更新 release_table_share(share); mysql_mutex_unlock(\u0026LOCK_open); MDL_deadlock_handler mdl_deadlock_handler(ot_ctx); bool wait_result; thd-\u003epush_internal_handler(\u0026mdl_deadlock_handler); uint deadlock_weight = ot_ctx-\u003ecan_back_off() ? MDL_wait_for_subgraph::DEADLOCK_WEIGHT_DML : mdl_ticket-\u003eget_deadlock_weight(); wait_result = tdc_wait_for_old_version(thd, table_list-\u003edb, table_list-\u003etable_name, ot_ctx-\u003eget_timeout(), deadlock_weight); thd-\u003epop_internal_handler(); if (wait_result) return true; goto retry_share; } if (thd-\u003eopen_tables \u0026\u0026 thd-\u003eopen_tables-\u003es-\u003eversion() != share-\u003eversion()) { /* 如果 version 改变，让步后重新开表 */ // 清理操作 ... return true; } } mysql_mutex_unlock(\u0026LOCK_open); // Step 6. 由 TABLE_SHARE 构建 TABLE 对象 { dd::cache::Dictionary_client::Auto_releaser releaser(thd-\u003edd_client()); const dd::Table *table_def = nullptr; if (!(flags \u0026 MYSQL_OPEN_NO_NEW_TABLE_IN_SE) \u0026\u0026 thd-\u003edd_client()-\u003eacquire(share-\u003edb.str, share-\u003etable_name.str, \u0026table_def)) { goto err_lock; } if (table_def \u0026\u0026 table_def-\u003ehidden() == dd::Abstract_table::HT_HIDDEN_SE) { my_error(ER_NO_SUCH_TABLE, MYF(0), table_list-\u003edb, table_list-\u003etable_name); goto err_lock; } /* make a new table */ if (!(table = (TABLE *)my_malloc(key_memory_TABLE, sizeof(*table), MYF(MY_WME)))) goto err_lock; error = open_table_from_share( thd, share, alias, ((flags \u0026 MYSQL_OPEN_NO_NEW_TABLE_IN_SE) ? 0 : ((uint)(HA_OPEN_KEYFILE | HA_OPEN_RNDFILE | HA_GET_INDEX | HA_TRY_READ_ONLY))), EXTRA_RECORD, thd-\u003eopen_options, table, false, table_def); if (error) { // 清理操作 ... goto err_lock; } else if (share-\u003ecrashed) { switch (thd-\u003elex-\u003esql_command) { case SQLCOM_ALTER_TABLE: case SQLCOM_REPAIR: case SQLCOM_CHECK: case SQLCOM_SHOW_CREATE: break; // 可以处理的 case default: // 清理操作 ... goto err_lock; } } /* Finalize the process of TABLE creation by loading table triggers */ if (open_table_entry_fini(thd, share, table_def, table)) { // 清理操作 ... goto err_lock; } } // Step 7. 将新生成的 TABLE 对象加入当前连接的 table cache { Table_cache *tc = table_cache_manager.get_cache(thd); tc-\u003elock(); if (tc-\u003eadd_used_table(thd, table)) { tc-\u003eunlock(); goto err_lock; } tc-\u003eunlock(); } thd-\u003estatus_var.table_open_cache_misses++; table_found: // 当前有了 TABLE 对象 table-\u003emdl_ticket = mdl_ticket; table-\u003enext = thd-\u003eopen_tables; /* Link into simple list */ thd-\u003eset_open_tables(table); table-\u003ereginfo.lock_type = TL_READ; /* Assume read */ reset: // 成功，初始化返回 table-\u003ereset(); table-\u003eset_created(); table_list-\u003eset_updatable(); table_list-\u003eset_insertable(); table_list-\u003etable = table; // skipping partitions bitmap setting in MYSQL_OPEN_NO_NEW_TABLE_IN_SE // ... table-\u003einit(thd, table_list); return false; err_lock: // 失败 mysql_mutex_lock(\u0026LOCK_open); release_table_share(share); mysql_mutex_unlock(\u0026LOCK_open); return true; } 考虑所有 cache 都穿透的情况，则此时在 get_table_share 中，通过 DD 接口从元数据表读取相应（表）对象的元数据记录，再以之填充新生成的 TABLE_SHARE。\n3.2 Server 层表对象缓存 从前面 open_table代码可见，获取 TABLE_SHARE 和构建 TABLE 实体对象过程中也涉及多层 cache 缓存机制。首先是 Table_cache_manager 缓存了 TABLE 对象，维护了所有正在使用或曾经打开过的 TABLE 对象，其大小由 table_cache_size 维护，内部按 THD 分片为 table_cache_instances 个 Table_cache。每个 Table_cache 内部由 object name（例如某张用户表） 映射到 Table_cache_element，可见 Table_cache_element 唯一对应一个 object，因此也唯一对应一个 TABLE_SHARE，其内部链接了这个缓存分片内中的所有由此 TABLE_SHARE 生成的 TABLE 实例。\n如果 Table_cache_manager 缓存穿透，则会去 Table_definition_cache 缓存寻找是否有存在 TABLE_SHARE 对象，其大小设置为 min(400 + table_cache_size / 2, 2000)。 如果 Table_definition_cache 进一步穿透，则会去 InnoDB 层读取元数据构建 TABLE_SHARE。\n另外，在 InnoDB 也为每一个 InnoDB 表加载一个数据字典对象，这些对象的集合就是 InnoDB 中的 data dictionary。InnoDB 的 dictionary system 以 全局 dict_sys_t 管理，而单个表对象对应 dict_table_t，类似的，索引对象对应 dict_index_t，列对象对应 dict_col_t 等。InnoDB 同样通过读取元数据表记录来构建 dict_table_t 对象，并且 dict_sys_t 中也有两个 dict_table_t 缓存，分别以 table name 和 table id 进行映射关联，其最大容量限制和 Table_definition_cache 一致。\n版权声明：如需转载或引用，请附加本文链接并注明来源。 ",
  "wordCount" : "1171",
  "inLanguage": "zh",
  "datePublished": "2023-11-05T00:00:00Z",
  "dateModified": "2023-11-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/mysql/meta/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title="MZY&#39;s Blog (Alt + H)">MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/mysql/">MySQL</a></div>
    <h1 class="post-title">
      MySQL 如何准备开启一个表
    </h1>
    <div class="post-meta"><span title='2023-11-05 00:00:00 +0000 UTC'>十一月 5, 2023</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;Miao Zheyu&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e5%89%8d%e8%a8%80" aria-label="1. 前言">1. 前言</a></li>
                    <li>
                        <a href="#2-%e5%85%83%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86" aria-label="2. 元数据管理">2. 元数据管理</a><ul>
                            
                    <li>
                        <a href="#21-%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8" aria-label="2.1 元数据的物理存储">2.1 元数据的物理存储</a></li>
                    <li>
                        <a href="#22-%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84" aria-label="2.2 元数据的内存结构">2.2 元数据的内存结构</a></li>
                    <li>
                        <a href="#23-%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84-cache-%e7%bc%93%e5%ad%98" aria-label="2.3 元数据的 cache 缓存">2.3 元数据的 cache 缓存</a></li></ul>
                    </li>
                    <li>
                        <a href="#3-%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="3. 元数据的使用">3. 元数据的使用</a><ul>
                            
                    <li>
                        <a href="#31-server-%e5%b1%82%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="3.1 Server 层元数据的使用">3.1 Server 层元数据的使用</a></li>
                    <li>
                        <a href="#32-server-%e5%b1%82%e8%a1%a8%e5%af%b9%e8%b1%a1%e7%bc%93%e5%ad%98" aria-label="3.2 Server 层表对象缓存">3.2 Server 层表对象缓存</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><h3 id="1-前言">1. 前言<a hidden class="anchor" aria-hidden="true" href="#1-前言">#</a></h3>
<p>   大家都知道元数据（Metadata）是用来描述数据的数据，没有元数据的情况下我们就没办法理解、使用数据库中存储的数据。本文通过 InnoDB 开启一个表的流程来讨论 InnoDB 的元信息管理和相关开表流程代码。</p>
<h3 id="2-元数据管理">2. 元数据管理<a hidden class="anchor" aria-hidden="true" href="#2-元数据管理">#</a></h3>
<h4 id="21-元数据的物理存储">2.1 元数据的物理存储<a hidden class="anchor" aria-hidden="true" href="#21-元数据的物理存储">#</a></h4>
<p>   在 MySQL 8.0 之前，Server 层和存储引擎层会各自保留一份元数据（schema name，table definition 等），不仅在信息存储上有着重复冗余，而且可能存在两者之间存储的元数据不同步的现象。MySQL 在 8.0 中引入了 data dictionary 来进行 Server 层和不同引擎间统一的元数据管理，这些元数据都存储在 InnoDB 引擎的表中，Server 层和引擎层共享一份元数据，且支持原子性。</p>
<p>   这些元数据对应的 InnoDB 引擎表我们一般称为系统表，其表结构是固定的直接定义在代码类结构中（因此不再需要记录额外的元数据，要不然就套娃了），对应表文件在整个 MySQL 进行初始化时就建立了，有如 <code>tables</code>、<code>columns</code>、<code>indexes</code>、<code>foreign_keys</code>等系统表。可以通过下面的 SQL 在 debug 版本查看所有系统表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SET</span><span class="w"> </span><span class="k">SESSION</span><span class="w"> </span><span class="n">debug</span><span class="o">=</span><span class="s1">&#39;+d,skip_dd_table_access_check&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">schema_id</span><span class="p">,</span><span class="w"> </span><span class="n">hidden</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">mysql</span><span class="p">.</span><span class="n">tables</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">hidden</span><span class="o">=</span><span class="s1">&#39;System&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">type</span><span class="o">=</span><span class="s1">&#39;BASE TABLE&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>   对于某张用户表来说，其元数据就是通过这些系统表对应的行内容记录构成，其逻辑关系可以近似看成是一颗树关联结构。其顶层入口是 table 表（mysql.tables）中的对应唯一记录，再通过记录的 table id 等索引项关联到如 columns、indexes 等各元数据系统表，进而获取这个表对应的元数据的记录内容。</p>
<!-- ![DD_store](DD_store.png) -->
<center><img src="DD_store.png" width="70%" /></center>
<h4 id="22-元数据的内存结构">2.2 元数据的内存结构<a hidden class="anchor" aria-hidden="true" href="#22-元数据的内存结构">#</a></h4>
<p>   在明确了 DD 元信息在物理层面的存储格式后，我们能够很清楚的知道，当需要构建一张用户表的元数据时，我们首先需要访问所有需要的系统表（元数据表），并依次在各系统表内找到对应这张用户表的相应记录，然后用这些元数据记录构建出用户表的内存对象。</p>
<p>   元数据表本身对应的内存对象结构是从 <code>Object_table</code> 类从派生出来的，有 <code>Entity_object_table_impl</code> 和 <code>Object_table_impl</code> 两大类。前者对应持久化有对应 Entity_object 的基本 DD 表，而后者对应着需要通过前者关联访问的 DD 表（不能直接被 create，search，drop）。两者再分别对应派生出 <code>Tables</code>、<code>Tablespaces</code>、&hellip; 和 <code>Columns</code>、<code>Indexes</code>、&hellip; 等具体内存结构体，一一对应各元数据系统表。<strong>注意一下</strong>，上面提到的这些内存对象是元数据表本身的内存对象，也就是访问元数据表所使用的内存对象，而非某一张用户表的内存对象。</p>
<p>   类似的，对于一张用户表，也是通过对应的元数据记录构建其内存对象结构。一般从 <code>Entity_object_impl</code> 类从派生出来的，像常用的 <code>Table_impl</code> 和 <code>View_impl</code> 分别表示用户表和视图对应元数据的内存对象。</p>
<p>   （当局部缓存穿透时）这些 objects 的操作逻辑被封装在 <code>Storage_adapter</code> 中，通过提供的 get() / drop() / store() 等接口，遍历查询或修改所有所需元数据表（btree 结构）中对应的 record，构建或持久性相应的 object 内存对象由/到引擎层。</p>
<h4 id="23-元数据的-cache-缓存">2.3 元数据的 cache 缓存<a hidden class="anchor" aria-hidden="true" href="#23-元数据的-cache-缓存">#</a></h4>
<p>   从上述操作中可以看出，直接从元数据表构建 DD object 内存对象是开销十分巨大的，过程中需要物理访问并索引多个 Btree 索引。因此 MySQL 建立了多层的 DD Cache 来就可能减小元数据的访问开销，一般称为元数据的 3 层缓存架构：</p>
<ul>
<li>每个 client 的独享缓存，即线程 THD 独占的 <code>Dictionary_client</code> 结构，其中有 <em>committed、uncommitted、dropped 三类 objects map</em>，最初 <strong>acquire</strong> 的 object 会被加入到committed map 中，client 调用 <strong>store</strong> 或 <strong>update</strong> 接口时将 object 放到 uncommitted map 中，然后在事务提交后将相应 objects 从 uncommitted map 移到 committed map 中，而调用 <strong>drop</strong> 接口会将 objects 加入 dropped map。当访问 Dictionary_client 穿透时，从 Shared_dictionary_cache 获取；</li>
<li>Server 全局唯一的共享缓存，使用单例 <code>Shared_dictionary_cache</code> 来实现，其实质上也是 objects map 集合。在此缓存层相同 key 对应的 DD objects 对象唯一，这里的 key 其实就是对应元数据表的索引 key。当 Shared_dictionary_cache 穿透时，通过 <code>Storage_adapter</code> 从 InnoDB handler 读取元数据表记录。</li>
<li>存储引擎层（元数据表数据直接 BP 缓存），系统表的访问模式和普通用户表基本一致，注意采用的是 <strong>READ_COMMITTED</strong> 隔离级别。</li>
</ul>
<h3 id="3-元数据的使用">3. 元数据的使用<a hidden class="anchor" aria-hidden="true" href="#3-元数据的使用">#</a></h3>
<h4 id="31-server-层元数据的使用">3.1 Server 层元数据的使用<a hidden class="anchor" aria-hidden="true" href="#31-server-层元数据的使用">#</a></h4>
<p>   在前面实现 DD 元数据的管理后，MySQL 就能够通过使用元数据构建访问用户表的环境，这也就是我们常说的“开表”逻辑。前面我们已经介绍了元数据表本身的内存对象，通过访问元数据表相应记录，我们可以进一步构建用户表（或其他内容，如视图等）的内存对象。</p>
<p>   首先我们需要知晓 Server 层的两个关键结构体 <code>TABLE_SHARE</code> 和 <code>TABLE</code>:</p>
<ul>
<li>一张表被初次访问时，MySQL 会其建立一个 <strong>TABLE_SHARE</strong> 对象，与其与引擎层中的对应表 <code>dict_table_t</code> 相对应关联。TABLE_SHARE 是静态的，不能修改的，且一张表只存在一份，其中记录表定义相关的一些 DD 信息，如包含的字段等。TABLE_SHARE 只有在表结构被修改后才会删除，或者缓存使用满了会淘汰。简单的说，TABLE_SHARE 就是某张表定义的实体化对象。</li>
<li>对每一个会话，MySQL 会通过 TABLE_SHARE 会为查询中涉及的每个表建一个 <strong>TABLE</strong> 实体对象，这一过程叫表结构实例化。如果是 InnoDB 表还会创建 InnoDB 层的 handler，server 层会话通过 TABLE 对象经引擎层操作表文件实体。可以将 TABLE 对象看做表在 server 层的映射，将 handler 看做其为操作底层数据文件而在引擎层创建的句柄。</li>
</ul>
<p>   而“开表”逻辑就是通过访问元数据来获取 TABLE_SHARE 和构建 TABLE 实体对象的过程。我们具体看下 <code>open_table</code> 的代码逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">open_table</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">,</span> <span class="n">Table_ref</span> <span class="o">*</span><span class="n">table_list</span><span class="p">,</span> <span class="n">Open_table_context</span> <span class="o">*</span><span class="n">ot_ctx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Step 0. 做一些前置检查...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Step 1. 除特殊 DD 表等场景，LOCK TABLES mode(LTM)下校验是否表对象都是 pre-opened 的；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Step 2. 非 LTM 模式（通常的模式），根据 mdl 请求模式获取 mdl 锁；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MYSQL_OPEN_HAS_MDL_LOCK</span> <span class="o">|</span> <span class="n">MYSQL_OPEN_SECONDARY_ENGINE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果需要 write_lock mdl，还要获取 global read lock 保证正确冲突性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">open_table_get_mdl_lock</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">ot_ctx</span><span class="p">,</span> <span class="n">table_list</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdl_ticket</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">mdl_ticket</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* caller 获取过 MDL 锁 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">mdl_ticket</span> <span class="o">=</span> <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">mdl_request</span><span class="p">.</span><span class="n">ticket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Step 3. 检查目标表的存在性；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">table_list</span><span class="o">-&gt;</span><span class="n">open_strategy</span> <span class="o">==</span> <span class="n">Table_ref</span><span class="o">::</span><span class="n">OPEN_IF_EXISTS</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">open_strategy</span> <span class="o">==</span> <span class="n">Table_ref</span><span class="o">::</span><span class="n">OPEN_FOR_CREATE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">check_if_table_exists</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">table_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exists</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* 空读 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exists</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* table 不存在于 DD，升级到 EXCLUSIVE MDL lock. */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">table_list</span><span class="o">-&gt;</span><span class="n">open_strategy</span> <span class="o">==</span> <span class="n">Table_ref</span><span class="o">::</span><span class="n">OPEN_FOR_CREATE</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MYSQL_OPEN_FORCE_SHARED_MDL</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">                     <span class="n">MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">MDL_deadlock_handler</span> <span class="n">mdl_deadlock_handler</span><span class="p">(</span><span class="n">ot_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">push_internal_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdl_deadlock_handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">wait_result</span> <span class="o">=</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">mdl_context</span><span class="p">.</span><span class="n">upgrade_shared_lock</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">mdl_request</span><span class="p">.</span><span class="n">ticket</span><span class="p">,</span> <span class="n">MDL_EXCLUSIVE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">thd</span><span class="o">-&gt;</span><span class="n">variables</span><span class="p">.</span><span class="n">lock_wait_timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">pop_internal_handler</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Deadlock or timeout occurred while upgrading the lock. */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">wait_result</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table_list</span><span class="o">-&gt;</span><span class="n">open_strategy</span> <span class="o">==</span> <span class="n">Table_ref</span><span class="o">::</span><span class="n">OPEN_STUB</span><span class="p">)</span> <span class="cm">/* 底层不真打开 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Step 4. Table 存在，尝试开表，首先从 table_cache_manager 这个缓存找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">retry_share</span> <span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Table_cache</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">table_cache_manager</span><span class="p">.</span><span class="n">get_cache</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">tc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table_list</span><span class="o">-&gt;</span><span class="n">is_view</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="n">table</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">get_table</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">share</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Case 1. 找到未使用的 TABLE object */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MYSQL_OPEN_IGNORE_FLUSH</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 检查 DD 的版本是否过老或不一致 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_tables</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_tables</span><span class="o">-&gt;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">()</span> <span class="o">!=</span> <span class="n">share</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">tc</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">table</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">rebind_psi</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">table</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">ha_extra</span><span class="p">(</span><span class="n">HA_EXTRA_RESET_STATE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">thd</span><span class="o">-&gt;</span><span class="n">status_var</span><span class="p">.</span><span class="n">table_open_cache_hits</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">table_found</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">share</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Case 2. 无未使用 TABLE 对象，但是找到表的 TABLE_SHARE */</span>
</span></span><span class="line"><span class="cl">    <span class="n">mysql_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tc</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">share</span><span class="o">-&gt;</span><span class="n">increment_ref_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">share_found</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* Case 3. 无未使用 TABLE 对象，也无表的 TABLE_SHARE */</span>
</span></span><span class="line"><span class="cl">    <span class="n">tc</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">mysql_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Step 5. 获取 TABLE_SHARE：
</span></span></span><span class="line"><span class="cl"><span class="c1">// 首先从 table_def_cache 缓存里找，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 穿透情况下确认 schema MDL 锁后建立新 TABLE_SHARE，并从元数据表读取记录填充。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">share</span> <span class="o">=</span> <span class="n">get_table_share_with_discover</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">thd</span><span class="p">,</span> <span class="n">table_list</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key_length</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MYSQL_OPEN_SECONDARY_ENGINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 失败清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">table_list</span><span class="o">-&gt;</span><span class="n">is_view</span><span class="p">()</span> <span class="o">||</span> <span class="n">share</span><span class="o">-&gt;</span><span class="n">is_view</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果是 view 对象情况下的处理 */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// return ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">share_found</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MYSQL_OPEN_IGNORE_FLUSH</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">share</span><span class="o">-&gt;</span><span class="n">has_old_version</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 释放对 shard 的 reference，等待老版本 table share 更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">release_table_share</span><span class="p">(</span><span class="n">share</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">mysql_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">MDL_deadlock_handler</span> <span class="n">mdl_deadlock_handler</span><span class="p">(</span><span class="n">ot_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">wait_result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">thd</span><span class="o">-&gt;</span><span class="n">push_internal_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdl_deadlock_handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint</span> <span class="n">deadlock_weight</span> <span class="o">=</span> <span class="n">ot_ctx</span><span class="o">-&gt;</span><span class="n">can_back_off</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">?</span> <span class="n">MDL_wait_for_subgraph</span><span class="o">::</span><span class="nl">DEADLOCK_WEIGHT_DML</span>
</span></span><span class="line"><span class="cl">                                 <span class="p">:</span> <span class="n">mdl_ticket</span><span class="o">-&gt;</span><span class="n">get_deadlock_weight</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">wait_result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">tdc_wait_for_old_version</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span> <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">table_name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">ot_ctx</span><span class="o">-&gt;</span><span class="n">get_timeout</span><span class="p">(),</span> <span class="n">deadlock_weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">thd</span><span class="o">-&gt;</span><span class="n">pop_internal_handler</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">wait_result</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">retry_share</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_tables</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_tables</span><span class="o">-&gt;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">()</span> <span class="o">!=</span> <span class="n">share</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 如果 version 改变，让步后重新开表 */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">mysql_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Step 6. 由 TABLE_SHARE 构建 TABLE 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">dd</span><span class="o">::</span><span class="n">cache</span><span class="o">::</span><span class="n">Dictionary_client</span><span class="o">::</span><span class="n">Auto_releaser</span> <span class="n">releaser</span><span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">dd_client</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dd</span><span class="o">::</span><span class="n">Table</span> <span class="o">*</span><span class="n">table_def</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MYSQL_OPEN_NO_NEW_TABLE_IN_SE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">dd_client</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">acquire</span><span class="p">(</span><span class="n">share</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">str</span><span class="p">,</span> <span class="n">share</span><span class="o">-&gt;</span><span class="n">table_name</span><span class="p">.</span><span class="n">str</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="o">&amp;</span><span class="n">table_def</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">table_def</span> <span class="o">&amp;&amp;</span> <span class="n">table_def</span><span class="o">-&gt;</span><span class="n">hidden</span><span class="p">()</span> <span class="o">==</span> <span class="n">dd</span><span class="o">::</span><span class="n">Abstract_table</span><span class="o">::</span><span class="n">HT_HIDDEN_SE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">my_error</span><span class="p">(</span><span class="n">ER_NO_SUCH_TABLE</span><span class="p">,</span> <span class="n">MYF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">table_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* make a new table */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="n">TABLE</span> <span class="o">*</span><span class="p">)</span><span class="n">my_malloc</span><span class="p">(</span><span class="n">key_memory_TABLE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">table</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">MYF</span><span class="p">(</span><span class="n">MY_WME</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">error</span> <span class="o">=</span> <span class="n">open_table_from_share</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">thd</span><span class="p">,</span> <span class="n">share</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MYSQL_OPEN_NO_NEW_TABLE_IN_SE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="o">?</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">             <span class="o">:</span> <span class="p">((</span><span class="n">uint</span><span class="p">)(</span><span class="n">HA_OPEN_KEYFILE</span> <span class="o">|</span> <span class="n">HA_OPEN_RNDFILE</span> <span class="o">|</span> <span class="n">HA_GET_INDEX</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">                       <span class="n">HA_TRY_READ_ONLY</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">        <span class="n">EXTRA_RECORD</span><span class="p">,</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_options</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">table_def</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">share</span><span class="o">-&gt;</span><span class="n">crashed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">lex</span><span class="o">-&gt;</span><span class="n">sql_command</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">SQLCOM_ALTER_TABLE</span><span class="p">:</span> <span class="k">case</span> <span class="nl">SQLCOM_REPAIR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">SQLCOM_CHECK</span><span class="p">:</span> <span class="k">case</span> <span class="nl">SQLCOM_SHOW_CREATE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span> <span class="c1">// 可以处理的 case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Finalize the process of TABLE creation by loading table triggers */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">open_table_entry_fini</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">share</span><span class="p">,</span> <span class="n">table_def</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 清理操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Step 7. 将新生成的 TABLE 对象加入当前连接的 table cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Table_cache</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="n">table_cache_manager</span><span class="p">.</span><span class="n">get_cache</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">add_used_table</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">tc</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">err_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">tc</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">thd</span><span class="o">-&gt;</span><span class="n">status_var</span><span class="p">.</span><span class="n">table_open_cache_misses</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">table_found</span><span class="p">:</span> <span class="c1">// 当前有了 TABLE 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">mdl_ticket</span> <span class="o">=</span> <span class="n">mdl_ticket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">table</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">open_tables</span><span class="p">;</span> <span class="cm">/* Link into simple list */</span>
</span></span><span class="line"><span class="cl">  <span class="n">thd</span><span class="o">-&gt;</span><span class="n">set_open_tables</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">table</span><span class="o">-&gt;</span><span class="n">reginfo</span><span class="p">.</span><span class="n">lock_type</span> <span class="o">=</span> <span class="n">TL_READ</span><span class="p">;</span> <span class="cm">/* Assume read */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">reset</span><span class="p">:</span> <span class="c1">// 成功，初始化返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">table</span><span class="o">-&gt;</span><span class="n">set_created</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">set_updatable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">set_insertable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">table_list</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// skipping partitions bitmap setting in MYSQL_OPEN_NO_NEW_TABLE_IN_SE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">table</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">table_list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">err_lock</span><span class="p">:</span> <span class="c1">// 失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mysql_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">release_table_share</span><span class="p">(</span><span class="n">share</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mysql_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LOCK_open</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   考虑所有 cache 都穿透的情况，则此时在 <code>get_table_share</code> 中，通过 DD 接口从元数据表读取相应（表）对象的元数据记录，再以之填充新生成的 TABLE_SHARE。</p>
<h4 id="32-server-层表对象缓存">3.2 Server 层表对象缓存<a hidden class="anchor" aria-hidden="true" href="#32-server-层表对象缓存">#</a></h4>
<p>   从前面 <code>open_table</code>代码可见，获取 TABLE_SHARE 和构建 TABLE 实体对象过程中也涉及多层 cache 缓存机制。首先是 <code>Table_cache_manager</code> 缓存了 TABLE 对象，维护了所有正在使用或曾经打开过的 TABLE 对象，其大小由 table_cache_size 维护，内部按 THD 分片为 table_cache_instances 个 <code>Table_cache</code>。每个 <code>Table_cache</code> 内部由 object name（例如某张用户表） 映射到 <code>Table_cache_element</code>，可见 <code>Table_cache_element</code> 唯一对应一个 object，因此也唯一对应一个 TABLE_SHARE，其内部链接了这个缓存分片内中的所有由此 TABLE_SHARE 生成的 TABLE 实例。</p>
<p>   如果 <code>Table_cache_manager</code> 缓存穿透，则会去 <code>Table_definition_cache</code> 缓存寻找是否有存在 TABLE_SHARE 对象，其大小设置为 <code>min(400 + table_cache_size / 2, 2000)</code>。 如果 <code>Table_definition_cache</code> 进一步穿透，则会去 InnoDB 层读取元数据构建 TABLE_SHARE。</p>
<p>   另外，在 InnoDB 也为每一个 InnoDB 表加载一个数据字典对象，这些对象的集合就是 InnoDB 中的 data dictionary。InnoDB 的 dictionary system 以 全局 <code>dict_sys_t</code> 管理，而单个表对象对应 <code>dict_table_t</code>，类似的，索引对象对应 <code>dict_index_t</code>，列对象对应 <code>dict_col_t</code> 等。InnoDB 同样通过读取元数据表记录来构建 <code>dict_table_t</code> 对象，并且 <code>dict_sys_t</code> 中也有两个 <code>dict_table_t</code> 缓存，分别以 table name 和 table id 进行映射关联，其最大容量限制和 <code>Table_definition_cache</code> 一致。</p>
<p><img loading="lazy" src="DD_cache.png" alt="DD_cache"  />
</p>
<hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/mysql/">mysql</a></li>
      <li><a href="https://mzyee.github.io/tags/dictionary/">dictionary</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://mzyee.github.io/posts/mysql/redo/">
    <span class="title">下一页 »</span>
    <br>
    <span>InnoDB Redo 日志系统</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
