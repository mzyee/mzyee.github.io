<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>InnoDB MVCC 逻辑学习 | MZY&#39;s Blog</title>
<meta name="keywords" content="MySQL, Undo, MVCC">
<meta name="description" content="InnoDB MVCC 逻辑学习">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/mysql/mvcc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.78ed8947c1508d00bdf7a3061370dcaebcd4ba680f4567ec440d26a4043b4e64.css" integrity="sha256-eO2JR8FQjQC996MGE3DcrrzUumgPRWfsRA0mpAQ7TmQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="InnoDB MVCC 逻辑学习" />
<meta property="og:description" content="InnoDB MVCC 逻辑学习" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/mysql/mvcc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-05-01T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="InnoDB MVCC 逻辑学习"/>
<meta name="twitter:description" content="InnoDB MVCC 逻辑学习"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL",
      "item": "https://mzyee.github.io/posts/mysql/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "InnoDB MVCC 逻辑学习",
      "item": "https://mzyee.github.io/posts/mysql/mvcc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "InnoDB MVCC 逻辑学习",
  "name": "InnoDB MVCC 逻辑学习",
  "description": "InnoDB MVCC 逻辑学习",
  "keywords": [
    "MySQL", "Undo", "MVCC"
  ],
  "articleBody": "行记录多版本的实现逻辑 在初步了解 undo 系统 和 purge 系统后，我们来进一步了解 InnoDB MVCC 逻辑。\nInnoDB MVCC 基于 Undo log 实现，通过主键记录上由 roll_ptr 串联的 undo reocrd 来构建访问需要的历史 record 版本。InnoDB 表数据组织方式是主键聚簇索引，通过 undo 构建老版本的逻辑也只是对于主键索引而言的，二级索引不存在对应 undo record。InnoDB 二级索引通过索引键值加主键值组合来唯一确定一条记录，因此对于一条二级索引记录（包括 delete_mark 状态的），其对应了一条 undo 覆盖历史范围存在的主键记录（可能是当前存在的版本，也可能是构建的历史版本）。\n同时，访问通过 ReadView 来判断历史版本的数据可见性。对于主键记录实际上是判断历史主键 record 上的 tid）。因此，当二级索引记录无法通过其 page 上的 max tid 过滤时，需要找到（可能需要通过 undo 构建）其对应的主键记录版本再来判断可见性。\nInnoDB 通过函数 trx_undo_prev_version_build 构建聚集索引记录的前一个版本，这个函数会使用在： MVCC 读取路径（row_vers_build_for_[semi_]consistent_read）； Purge/Undo 路径（row_vers_old_has_index_entry）； 二级索引隐式锁判断（row_vers_find_matching）等路径上。\n构建老版本记录 trx_undo_prev_version_build 用来构建前一个版本的主键索引记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 /** 构建聚集索引记录某个版本 rec 的再前一个版本。 调用者必须持有聚集索引记录索引页的锁。*/ bool trx_undo_prev_version_build(const rec_t *index_rec, mtr_t *index_mtr, const rec_t *rec, const dict_index_t *index, ulint *offsets, mem_heap_t *heap, rec_t **old_vers, mem_heap_t *v_heap, const dtuple_t **vrow, ulint v_status, lob::undo_vers_t *lob_undo) { trx_undo_rec_t *undo_rec = nullptr; dtuple_t *entry; trx_id_t rec_trx_id; ulint type; undo_no_t undo_no; table_id_t table_id; trx_id_t trx_id; roll_ptr_t roll_ptr; upd_t *update = nullptr; byte *ptr; ulint info_bits; ulint cmpl_info; bool dummy_extern; byte *buf; roll_ptr = row_get_rec_roll_ptr(rec, index, offsets); *old_vers = nullptr; /* insert undo（说明是串上第一个记录）*/ if (trx_undo_roll_ptr_is_insert(roll_ptr)) { return true;} rec_trx_id = row_get_rec_trx_id(rec, index, offsets); bool is_temp = index-\u003etable-\u003eis_temporary(); // 获取 undo_rec 时会判断 rec_trx_id 是否被 purge_sys-\u003eview 可见 if (trx_undo_get_undo_rec(roll_ptr, rec_trx_id, heap, is_temp, index-\u003etable-\u003ename, \u0026undo_rec)) { // 当前 rec_trx_id 在 purge_sys-\u003eview 可见，更老的（prev）undo 可能版本都被处理了 if (v_status \u0026 TRX_UNDO_PREV_IN_PURGE) { /* 函数被 purge 流程中调用的特殊情况，用于 virtual row 处理 */ undo_rec = trx_undo_get_undo_rec_low(roll_ptr, heap, is_temp); } else { /* 正常情况，更老一个版本的 undo 不安全，到当前版本为止 */ return false; } } // 解析获取到的对应上一版本的 undo rec type_cmpl_t type_cmpl; ptr = trx_undo_rec_get_pars(undo_rec, \u0026type, \u0026cmpl_info, \u0026dummy_extern, \u0026undo_no, \u0026table_id, type_cmpl); if (table_id != index-\u003etable-\u003eid) return true; /*table 被重建，purge 遇到老 id 的 undo*/ ptr = trx_undo_update_rec_get_sys_cols(ptr, \u0026trx_id, \u0026roll_ptr, \u0026info_bits); ptr = trx_undo_rec_skip_row_ref(ptr, index); // 通过 undo 构建 upd_t *update ptr = trx_undo_update_rec_get_update(ptr, index, type, trx_id, roll_ptr, info_bits, heap, \u0026update, lob_undo, type_cmpl); ut_a(ptr); if (row_upd_changes_field_size_or_external(index, offsets, update)) { /* 如果前一个版本记录是被标记删除的，并且存在 disowned 的 blob， 则需要判断可见性这个版本记录的可见性， 如果 purge 可见，将其视为 missing history 处理， 这是因为上一版本记录 disowned 的 blob 可能已经被 purge 了。 可以省略 row_upd_changes_disowned_external(update) 调用， 但这样 purge_sys-\u003elatch 加锁更多，性能开销可更高。*/ if ((update-\u003einfo_bits \u0026 REC_INFO_DELETED_FLAG) \u0026\u0026 row_upd_changes_disowned_external(update)) { bool missing_ext; rw_lock_s_lock(\u0026purge_sys-\u003elatch, UT_LOCATION_HERE); missing_ext = purge_sys-\u003eview.changes_visible(trx_id, index-\u003etable-\u003ename); rw_lock_s_unlock(\u0026purge_sys-\u003elatch); if (missing_ext) { /* treat as a fresh insert, not to cause assertion error at the caller. */ if (update != nullptr) { update-\u003ereset(); } return true; } } // 通过 undo 还原 entry = row_rec_to_index_entry(rec, index, offsets, heap); row_upd_index_replace_new_col_vals(entry, index, update, heap); buf = static_cast\u003cbyte *\u003e(mem_heap_alloc(heap, rec_get_converted_size(index, entry))); *old_vers = rec_convert_dtuple_to_rec(buf, index, entry); } else { buf = static_cast\u003cbyte *\u003e(mem_heap_alloc(heap, rec_offs_size(offsets))); *old_vers = rec_copy(buf, rec, offsets); // 通过 undo 还原 row_upd_rec_in_place(*old_vers, index, offsets, update, nullptr); } /* Set the old value (which is the after image of an update) in the update vector to dtuple vrow */ if (v_status \u0026 TRX_UNDO_GET_OLD_V_VALUE) row_upd_replace_vcol((dtuple_t *)*vrow, index-\u003etable, update, false, nullptr, nullptr); if (vrow \u0026\u0026 !(cmpl_info \u0026 UPD_NODE_NO_ORD_CHANGE)) { // 构建老版本的 virtual row // ... } if (update != nullptr) { update-\u003ereset(); } return true; } MVCC 一致性读取路径 以 row_search_mvcc 查询为例，当 cursor 定位到确切 user_record 上后，如果是无锁一致性 MVCC 读并且隔离级别大于 READ_UNCOMMITTED 时，此时会通过查询所持有的 readview 判断对应记录是否可见（lock_clust/sec_rec_cons_read_sees），对于二级索引无法判断是还需要回表到主键上处理，对于主键索引如果此记录不可见，则会通过 row_vers_build_for_consistent_read 构建目标 readview 可见的历史行记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /** 构建一致性读取应该看到的聚集索引记录的版本。 函数假设当前 rec 上的事务 id 是一致性读取不应该看到的。*/ dberr_t row_vers_build_for_consistent_read( const rec_t *rec, // 聚集索引中的记录，调用者必须持有 page latch，即该记录版本堆栈的顶部 mtr_t *mtr, // 持有 rec 上锁的 mtr，并且还将持有 purge_view 上的锁 dict_index_t *index, ulint **offsets, ReadView *view, // 目标视图 mem_heap_t **offset_heap, mem_heap_t *in_heap, rec_t **old_vers, const dtuple_t **vrow, lob::undo_vers_t *lob_undo // 如果需要应用 blob 的 undo log ) { const rec_t *version; rec_t *prev_version; trx_id_t trx_id; mem_heap_t *heap = nullptr; byte *buf; dberr_t err; trx_id = row_get_rec_trx_id(rec, index, *offsets); if (lob_undo != nullptr) { lob_undo-\u003ereset(); } version = rec; for (;;) { mem_heap_t *prev_heap = heap; heap = mem_heap_create(1024, UT_LOCATION_HERE); if (vrow) { *vrow = nullptr; } bool purge_sees = trx_undo_prev_version_build(rec, mtr, version, index, *offsets, heap, \u0026prev_version, nullptr, vrow, 0, lob_undo); err = (purge_sees) ? DB_SUCCESS : DB_MISSING_HISTORY; // purge view（也是最老的 readview）可见，因此 undo 可能被 purge if (prev_heap != nullptr) { mem_heap_free(prev_heap); } if (prev_version == nullptr) { /* 不存在更老的对应主键版本 */ *old_vers = nullptr; break; } *offsets = rec_get_offsets(prev_version, index, *offsets, ULINT_UNDEFINED, UT_LOCATION_HERE, offset_heap); trx_id = row_get_rec_trx_id(prev_version, index, *offsets); if (view-\u003echanges_visible(trx_id, index-\u003etable-\u003ename)) { /* 一直找到第一个 view 可见的目标历史行记录后 copy 并退出 */ buf = static_cast\u003cbyte *\u003e(mem_heap_alloc(in_heap, rec_offs_size(*offsets))); *old_vers = rec_copy(buf, prev_version, *offsets); if (vrow \u0026\u0026 *vrow) { *vrow = dtuple_copy(*vrow, in_heap); dtuple_dup_v_fld(*vrow, in_heap); } break; } version = prev_version; } mem_heap_free(heap); return err; } Purge/Undo 路径 当需要从二级索引 purge 标记删除的行时，会检查是否存在一个未被标记删除的、大于等于 purge view 范围的、且与 purge 目标二级索引记录字符集排序相等的主键行记录版本，如果存在（当前二级索引还会使用），则不会 purge 这个二级索引记录。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /** 检查是否存在某个大于等于 purge view 的非标记删除行记录版本（不可清理）和目标二级索引一致 */ bool row_vers_old_has_index_entry( bool also_curr, /*!\u003c in: true if also rec is included in the versions to search; otherwise only versions prior to it are searched */ const rec_t *rec, /*!\u003c in: record in the clustered index; the caller must have a latch on the page */ mtr_t *mtr, /*!\u003c in: mtr holding the latch on rec; it will also hold the latch on purge_view */ dict_index_t *index, /*!\u003c in: the secondary index */ const dtuple_t *ientry, /*!\u003c in: the secondary index entry */ roll_ptr_t roll_ptr, /*!\u003c in: roll_ptr for the purge record */ trx_id_t trx_id) /*!\u003c in: transaction ID on the purging record */ { const rec_t *version; rec_t *prev_version; dict_index_t *clust_index; ulint *clust_offsets; mem_heap_t *heap; mem_heap_t *heap2; dtuple_t *row; const dtuple_t *entry; ulint comp; const dtuple_t *vrow = nullptr; mem_heap_t *v_heap = nullptr; const dtuple_t *cur_vrow = nullptr; clust_index = index-\u003etable-\u003efirst_index(); comp = page_rec_is_comp(rec); heap = mem_heap_create(1024, UT_LOCATION_HERE); clust_offsets = rec_get_offsets(rec, clust_index, nullptr, ULINT_UNDEFINED, UT_LOCATION_HERE, \u0026heap); if (dict_index_has_virtual(index)) v_heap = mem_heap_create(100, UT_LOCATION_HERE); // also_curr == true，检查非 delete_mark 的当前 rec 是否和二级索引匹配 if (also_curr \u0026\u0026 !rec_get_deleted_flag(rec, comp)) { row_ext_t *ext; row = row_build(ROW_COPY_POINTERS, clust_index, rec, clust_offsets, nullptr, nullptr, nullptr, \u0026ext, heap); if (dict_index_has_virtual(index)) { // 存在 virtual row 处理 ... } else { // 构建二级索引对应 dtuple_t *entry entry = row_build_index_entry(row, ext, index, heap); // 字符集（非binary）比较输入目标 ientry 和主键二级索引部分是否一致 if (entry \u0026\u0026 dtuple_coll_eq(entry, ientry)) { mem_heap_free(heap); if (v_heap) { mem_heap_free(v_heap); } return true; } } } else if (dict_index_has_virtual(index)) { // 存在 virtual row 处理 ... } version = rec; // 检查是否存在非 delete_mark 的老版本 rec 和二级索引匹配 for (;;) { heap2 = heap; heap = mem_heap_create(1024, UT_LOCATION_HERE); vrow = nullptr; // 构建前一个版本行记录 trx_undo_prev_version_build( rec, mtr, version, clust_index, clust_offsets, heap, \u0026prev_version, nullptr, dict_index_has_virtual(index) ? \u0026vrow : nullptr, 0, nullptr); mem_heap_free(heap2); if (!prev_version) { /* 不存在更老的（purge 安全）版本 */ mem_heap_free(heap); if (v_heap) mem_heap_free(v_heap); return false; } clust_offsets = rec_get_offsets(prev_version, clust_index, nullptr, ULINT_UNDEFINED, UT_LOCATION_HERE, \u0026heap); if (dict_index_has_virtual(index)) { /* 存在 virtual row 处理 ... */ } if (!rec_get_deleted_flag(prev_version, comp)) { row_ext_t *ext; row = row_build(ROW_COPY_POINTERS, clust_index, prev_version, clust_offsets, nullptr, nullptr, nullptr, \u0026ext, heap); if (dict_index_has_virtual(index)) {/* 存在 virtual row 处理 ... */} // 构建二级索引对应 dtuple_t *entry entry = row_build_index_entry(row, ext, index, heap); /* If entry == NULL, the record contains unset BLOB pointers. This cheated be a freshly inserted record that can ignore. */ // 字符集（非binary）比较输入目标 ientry 和主键二级索引部分是否一致 if (entry \u0026\u0026 dtuple_coll_eq(entry, ientry)) { mem_heap_free(heap); if (v_heap) { mem_heap_free(v_heap); } return true; } } version = prev_version; } } 二级索引隐式锁判断 在做二级索引记录可见下判断时，当无法使用二级索引 page max tid 做过滤时，需要回表主键去检查是否存在一个活跃事务插入或修改了对应的二级索引记录。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* 查找是否存在 match/unmatch 的主键记录版本， 目前如果 sec rec 是标记删除的则寻找是否有 match 的记录版本， 如果 sec rec 是非标记删除的则去寻找是否有非 match 的记录版本 */ static bool row_vers_find_matching( bool looking_for_match, const dict_index_t *const clust_index, const rec_t *const clust_rec, ulint *\u0026clust_offsets, const dict_index_t *const sec_index, const rec_t *const sec_rec, const ulint *const sec_offsets, const bool comp, const trx_id_t trx_id, // 当前 cluster rec 对应的 tid，必然是活跃的 mtr_t *const mtr, mem_heap_t *\u0026heap) { const rec_t *version = clust_rec; trx_id_t version_trx_id = trx_id; // 这里是回表到的当前索引上 cluster_rec 对应 tid 还活跃，但是 sec_rec 可能和不是这个 tid 产生的，仍要进一步判断 // 只需要寻找当前索引 cluster_rec 对应 tid 产生的记录，如果是更老的 tid 产生的这个 sec_rec，由于这个行记录可以被后续 tid 修改，其一定已经不活跃了 while (version_trx_id == trx_id) { mem_heap_t *old_heap = heap; const dtuple_t *clust_vrow = nullptr; rec_t *prev_version = nullptr; heap = mem_heap_create(1024, UT_LOCATION_HERE); // 寻找前一个主键记录版本 trx_undo_prev_version_build( clust_rec, mtr, version, clust_index, clust_offsets, heap, \u0026prev_version, nullptr, dict_index_has_virtual(sec_index) ? \u0026clust_vrow : nullptr, 0, nullptr); mem_heap_free(old_heap); version = prev_version; if (version == nullptr) { version_trx_id = 0; } else { clust_offsets = rec_get_offsets(version, clust_index, nullptr, ULINT_UNDEFINED, UT_LOCATION_HERE, \u0026heap); version_trx_id = row_get_rec_trx_id(version, clust_index, clust_offsets); } /* ！这里需要判断是否由对应版本主键 prev version 到这个版本这次 “修改” 而产生的 sec_rec： sec_rec 是 non-delete marked（looking_for_match = false）： 如果发现 prev version 是 delete mark 的或 version 二级索引部分与 sec_rec 不一致（不 match）， 说明是由这个版本 version 修改产生的这个 sec_rec（老版本被更新过）， 因此仍活跃。 （sec_rec 活跃，prev version 非活跃 或 不一致 时，则说明对 prev version 的修改导致此 sec_rec 产生） sec_rec 是 delete marked（looking_for_match = true）： 如果发现 prev version 是 非 delete mark 且 version 二级索引部分与 sec_rec 一致（match）， 说明是由这个版本 version 修改产生的这个 sec_rec（老版本被更新过）， 因此仍活跃。， （sec_rec 非活跃，prev version 活跃 且 一致 时，则说明对 prev version 的修改导致此 sec_rec 产生） */ if (row_clust_vers_matches_sec( clust_index, version, clust_vrow, clust_offsets, sec_index, sec_rec, sec_offsets, comp, looking_for_match, heap) == looking_for_match) { return true; } } return false; } 版权声明：如需转载或引用，请附加本文链接并注明来源。 ",
  "wordCount" : "1699",
  "inLanguage": "zh",
  "datePublished": "2024-05-01T00:00:00Z",
  "dateModified": "2024-05-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/mysql/mvcc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title=" MZY&#39;s Blog (Alt + H)">
                <img src="https://mzyee.github.io/img/eye.jpg" alt="" aria-label="logo"
                    height="38"> MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/mysql/">MySQL</a></div>
    <h1 class="post-title">
      InnoDB MVCC 逻辑学习
    </h1>
    <div class="post-meta"><span title='2024-05-01 00:00:00 +0000 UTC'>五月 1, 2024</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;Miao Zheyu
      &nbsp;|&nbsp;📖 &nbsp;
      <ul class="post-tags-meta">
        <a href="https://mzyee.github.io/tags/mysql/">MySQL</a>
        <a href="https://mzyee.github.io/tags/undo/">&nbsp;Undo</a>
        <a href="https://mzyee.github.io/tags/mvcc/">&nbsp;MVCC</a>
      </ul>&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%a1%8c%e8%ae%b0%e5%bd%95%e5%a4%9a%e7%89%88%e6%9c%ac%e7%9a%84%e5%ae%9e%e7%8e%b0%e9%80%bb%e8%be%91" aria-label="行记录多版本的实现逻辑">行记录多版本的实现逻辑</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><h3 id="行记录多版本的实现逻辑">行记录多版本的实现逻辑<a hidden class="anchor" aria-hidden="true" href="#行记录多版本的实现逻辑">#</a></h3>
<p>   在初步了解 <a href="/posts/mysql/undo">undo 系统</a> 和 <a href="/posts/mysql/purge">purge 系统</a>后，我们来进一步了解 InnoDB MVCC 逻辑。</p>
<p>   InnoDB MVCC 基于 Undo log 实现，通过主键记录上由 roll_ptr 串联的 undo reocrd 来构建访问需要的历史 record 版本。InnoDB 表数据组织方式是主键聚簇索引，通过 undo 构建老版本的逻辑也只是对于主键索引而言的，二级索引不存在对应 undo record。InnoDB 二级索引通过索引键值加主键值组合来唯一确定一条记录，因此对于一条二级索引记录（包括 delete_mark 状态的），其对应了一条 undo 覆盖历史范围存在的主键记录（可能是当前存在的版本，也可能是构建的历史版本）。</p>
<center><img src="phy_undo2.png" width="100%" /></center>
<p>   同时，访问通过 ReadView 来判断历史版本的数据可见性。对于主键记录实际上是判断历史主键 record 上的 tid）。因此，当二级索引记录无法通过其 page 上的 max tid 过滤时，需要找到（可能需要通过 undo 构建）其对应的主键记录版本再来判断可见性。</p>
<p>   InnoDB 通过函数 trx_undo_prev_version_build 构建聚集索引记录的前一个版本，这个函数会使用在：
MVCC 读取路径（<code>row_vers_build_for_[semi_]consistent_read</code>）；
Purge/Undo 路径（<code>row_vers_old_has_index_entry</code>）；
二级索引隐式锁判断（<code>row_vers_find_matching</code>）等路径上。</p>
<ol start="0">
<li><strong>构建老版本记录</strong></li>
</ol>
<p><code>trx_undo_prev_version_build</code> 用来构建前一个版本的主键索引记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** 构建聚集索引记录某个版本 rec 的再前一个版本。
</span></span></span><span class="line"><span class="cl"><span class="cm">  调用者必须持有聚集索引记录索引页的锁。*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">trx_undo_prev_version_build</span><span class="p">(</span><span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">index_rec</span><span class="p">,</span> <span class="n">mtr_t</span> <span class="o">*</span><span class="n">index_mtr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="k">const</span> <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">ulint</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">rec_t</span> <span class="o">**</span><span class="n">old_vers</span><span class="p">,</span> <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">v_heap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">**</span><span class="n">vrow</span><span class="p">,</span> <span class="n">ulint</span> <span class="n">v_status</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">lob</span><span class="o">::</span><span class="n">undo_vers_t</span> <span class="o">*</span><span class="n">lob_undo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_undo_rec_t</span> <span class="o">*</span><span class="n">undo_rec</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_id_t</span> <span class="n">rec_trx_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo_no_t</span> <span class="n">undo_no</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">table_id_t</span> <span class="n">table_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_id_t</span> <span class="n">trx_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">roll_ptr_t</span> <span class="n">roll_ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">upd_t</span> <span class="o">*</span><span class="n">update</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">byte</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">info_bits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">cmpl_info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">dummy_extern</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">roll_ptr</span> <span class="o">=</span> <span class="n">row_get_rec_roll_ptr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">old_vers</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* insert undo（说明是串上第一个记录）*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">trx_undo_roll_ptr_is_insert</span><span class="p">(</span><span class="n">roll_ptr</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rec_trx_id</span> <span class="o">=</span> <span class="n">row_get_rec_trx_id</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">is_temp</span> <span class="o">=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">is_temporary</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取 undo_rec 时会判断 rec_trx_id 是否被 purge_sys-&gt;view 可见
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">trx_undo_get_undo_rec</span><span class="p">(</span><span class="n">roll_ptr</span><span class="p">,</span> <span class="n">rec_trx_id</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">is_temp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">undo_rec</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前 rec_trx_id 在 purge_sys-&gt;view 可见，更老的（prev）undo 可能版本都被处理了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">v_status</span> <span class="o">&amp;</span> <span class="n">TRX_UNDO_PREV_IN_PURGE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 函数被 purge 流程中调用的特殊情况，用于 virtual row 处理 */</span>
</span></span><span class="line"><span class="cl">      <span class="n">undo_rec</span> <span class="o">=</span> <span class="n">trx_undo_get_undo_rec_low</span><span class="p">(</span><span class="n">roll_ptr</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">is_temp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 正常情况，更老一个版本的 undo 不安全，到当前版本为止 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 解析获取到的对应上一版本的 undo rec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">type_cmpl_t</span> <span class="n">type_cmpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ptr</span> <span class="o">=</span> <span class="n">trx_undo_rec_get_pars</span><span class="p">(</span><span class="n">undo_rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmpl_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy_extern</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="o">&amp;</span><span class="n">undo_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table_id</span><span class="p">,</span> <span class="n">type_cmpl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">!=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/*table 被重建，purge 遇到老 id 的 undo*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ptr</span> <span class="o">=</span> <span class="n">trx_undo_update_rec_get_sys_cols</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trx_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">roll_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info_bits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ptr</span> <span class="o">=</span> <span class="n">trx_undo_rec_skip_row_ref</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过 undo 构建 upd_t *update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ptr</span> <span class="o">=</span> <span class="n">trx_undo_update_rec_get_update</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">trx_id</span><span class="p">,</span> <span class="n">roll_ptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">info_bits</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">update</span><span class="p">,</span> <span class="n">lob_undo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">type_cmpl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut_a</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">row_upd_changes_field_size_or_external</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">update</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果前一个版本记录是被标记删除的，并且存在 disowned 的 blob，
</span></span></span><span class="line"><span class="cl"><span class="cm">      则需要判断可见性这个版本记录的可见性，
</span></span></span><span class="line"><span class="cl"><span class="cm">      如果 purge 可见，将其视为 missing history 处理，
</span></span></span><span class="line"><span class="cl"><span class="cm">      这是因为上一版本记录 disowned 的 blob 可能已经被 purge 了。
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">      可以省略 row_upd_changes_disowned_external(update) 调用，
</span></span></span><span class="line"><span class="cl"><span class="cm">      但这样 purge_sys-&gt;latch 加锁更多，性能开销可更高。*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">update</span><span class="o">-&gt;</span><span class="n">info_bits</span> <span class="o">&amp;</span> <span class="n">REC_INFO_DELETED_FLAG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">         <span class="n">row_upd_changes_disowned_external</span><span class="p">(</span><span class="n">update</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">missing_ext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">rw_lock_s_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">missing_ext</span> <span class="o">=</span> <span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">.</span><span class="n">changes_visible</span><span class="p">(</span><span class="n">trx_id</span><span class="p">,</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">rw_lock_s_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">missing_ext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* treat as a fresh insert, not to cause assertion error at the caller. */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">update</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">update</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过 undo 还原
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">entry</span> <span class="o">=</span> <span class="n">row_rec_to_index_entry</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">row_upd_index_replace_new_col_vals</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">buf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">byte</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">mem_heap_alloc</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">rec_get_converted_size</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">entry</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">old_vers</span> <span class="o">=</span> <span class="n">rec_convert_dtuple_to_rec</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">byte</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">mem_heap_alloc</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">rec_offs_size</span><span class="p">(</span><span class="n">offsets</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">old_vers</span> <span class="o">=</span> <span class="n">rec_copy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过 undo 还原
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">row_upd_rec_in_place</span><span class="p">(</span><span class="o">*</span><span class="n">old_vers</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Set the old value (which is the after image of an update) in the
</span></span></span><span class="line"><span class="cl"><span class="cm">  update vector to dtuple vrow */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">v_status</span> <span class="o">&amp;</span> <span class="n">TRX_UNDO_GET_OLD_V_VALUE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">row_upd_replace_vcol</span><span class="p">((</span><span class="n">dtuple_t</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">vrow</span><span class="p">,</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">vrow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cmpl_info</span> <span class="o">&amp;</span> <span class="n">UPD_NODE_NO_ORD_CHANGE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构建老版本的 virtual row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">update</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">update</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>MVCC 一致性读取路径</strong></li>
</ol>
<p>以 row_search_mvcc 查询为例，当 cursor 定位到确切 user_record 上后，如果是无锁一致性 MVCC 读并且隔离级别大于 READ_UNCOMMITTED 时，此时会通过查询所持有的 readview 判断对应记录是否可见（<code>lock_clust/sec_rec_cons_read_sees</code>），对于二级索引无法判断是还需要回表到主键上处理，对于主键索引如果此记录不可见，则会通过 <code>row_vers_build_for_consistent_read</code> 构建目标 readview 可见的历史行记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** 构建一致性读取应该看到的聚集索引记录的版本。
</span></span></span><span class="line"><span class="cl"><span class="cm">   函数假设当前 rec 上的事务 id 是一致性读取不应该看到的。*/</span>
</span></span><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">row_vers_build_for_consistent_read</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="c1">// 聚集索引中的记录，调用者必须持有 page latch，即该记录版本堆栈的顶部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mtr_t</span> <span class="o">*</span><span class="n">mtr</span><span class="p">,</span> <span class="c1">// 持有 rec 上锁的 mtr，并且还将持有 purge_view 上的锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="n">ulint</span> <span class="o">**</span><span class="n">offsets</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReadView</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="c1">// 目标视图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mem_heap_t</span> <span class="o">**</span><span class="n">offset_heap</span><span class="p">,</span> <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">in_heap</span><span class="p">,</span> <span class="n">rec_t</span> <span class="o">**</span><span class="n">old_vers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">**</span><span class="n">vrow</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">lob</span><span class="o">::</span><span class="n">undo_vers_t</span> <span class="o">*</span><span class="n">lob_undo</span> <span class="c1">// 如果需要应用 blob 的 undo log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rec_t</span> <span class="o">*</span><span class="n">prev_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_id_t</span> <span class="n">trx_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">dberr_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">trx_id</span> <span class="o">=</span> <span class="n">row_get_rec_trx_id</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">lob_undo</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">lob_undo</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">version</span> <span class="o">=</span> <span class="n">rec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">prev_heap</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span> <span class="o">=</span> <span class="n">mem_heap_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vrow</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">vrow</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">purge_sees</span> <span class="o">=</span> <span class="n">trx_undo_prev_version_build</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">mtr</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                  <span class="o">&amp;</span><span class="n">prev_version</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">vrow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lob_undo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">purge_sees</span><span class="p">)</span> <span class="o">?</span> <span class="nl">DB_SUCCESS</span> <span class="p">:</span> <span class="n">DB_MISSING_HISTORY</span><span class="p">;</span> <span class="c1">// purge view（也是最老的 readview）可见，因此 undo 可能被 purge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">prev_heap</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">prev_heap</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">prev_version</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 不存在更老的对应主键版本 */</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">old_vers</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">offsets</span> <span class="o">=</span> <span class="n">rec_get_offsets</span><span class="p">(</span><span class="n">prev_version</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">ULINT_UNDEFINED</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="n">offset_heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">trx_id</span> <span class="o">=</span> <span class="n">row_get_rec_trx_id</span><span class="p">(</span><span class="n">prev_version</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">changes_visible</span><span class="p">(</span><span class="n">trx_id</span><span class="p">,</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 一直找到第一个 view 可见的目标历史行记录后 copy 并退出 */</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">byte</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">mem_heap_alloc</span><span class="p">(</span><span class="n">in_heap</span><span class="p">,</span> <span class="n">rec_offs_size</span><span class="p">(</span><span class="o">*</span><span class="n">offsets</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">old_vers</span> <span class="o">=</span> <span class="n">rec_copy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">prev_version</span><span class="p">,</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vrow</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">vrow</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">vrow</span> <span class="o">=</span> <span class="n">dtuple_copy</span><span class="p">(</span><span class="o">*</span><span class="n">vrow</span><span class="p">,</span> <span class="n">in_heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dtuple_dup_v_fld</span><span class="p">(</span><span class="o">*</span><span class="n">vrow</span><span class="p">,</span> <span class="n">in_heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">version</span> <span class="o">=</span> <span class="n">prev_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>Purge/Undo 路径</strong>
当需要从二级索引 purge 标记删除的行时，会检查是否存在一个未被标记删除的、大于等于 purge view 范围的、且与 purge 目标二级索引记录字符集排序相等的主键行记录版本，如果存在（当前二级索引还会使用），则不会 purge 这个二级索引记录。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** 检查是否存在某个大于等于 purge view 的非标记删除行记录版本（不可清理）和目标二级索引一致 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">row_vers_old_has_index_entry</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">also_curr</span><span class="p">,</span>         <span class="cm">/*!&lt; in: true if also rec is included in the
</span></span></span><span class="line"><span class="cl"><span class="cm">                           versions to search; otherwise only versions
</span></span></span><span class="line"><span class="cl"><span class="cm">                           prior to it are searched */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>       <span class="cm">/*!&lt; in: record in the clustered index; the
</span></span></span><span class="line"><span class="cl"><span class="cm">                            caller must have a latch on the page */</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_t</span> <span class="o">*</span><span class="n">mtr</span><span class="p">,</span>             <span class="cm">/*!&lt; in: mtr holding the latch on rec; it will
</span></span></span><span class="line"><span class="cl"><span class="cm">                            also hold the latch on purge_view */</span>
</span></span><span class="line"><span class="cl">    <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>    <span class="cm">/*!&lt; in: the secondary index */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">ientry</span><span class="p">,</span> <span class="cm">/*!&lt; in: the secondary index entry */</span>
</span></span><span class="line"><span class="cl">    <span class="n">roll_ptr_t</span> <span class="n">roll_ptr</span><span class="p">,</span>    <span class="cm">/*!&lt; in: roll_ptr for the purge record */</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_id_t</span> <span class="n">trx_id</span><span class="p">)</span>        <span class="cm">/*!&lt; in: transaction ID on the purging record */</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rec_t</span> <span class="o">*</span><span class="n">prev_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">clust_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="o">*</span><span class="n">clust_offsets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">heap2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">row</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">comp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">vrow</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">v_heap</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">cur_vrow</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">clust_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">first_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">comp</span> <span class="o">=</span> <span class="n">page_rec_is_comp</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">heap</span> <span class="o">=</span> <span class="n">mem_heap_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">clust_offsets</span> <span class="o">=</span> <span class="n">rec_get_offsets</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">ULINT_UNDEFINED</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="n">v_heap</span> <span class="o">=</span> <span class="n">mem_heap_create</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// also_curr == true，检查非 delete_mark 的当前 rec 是否和二级索引匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">also_curr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rec_get_deleted_flag</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">row_ext_t</span> <span class="o">*</span><span class="n">ext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">row</span> <span class="o">=</span> <span class="n">row_build</span><span class="p">(</span><span class="n">ROW_COPY_POINTERS</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">clust_offsets</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ext</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 存在 virtual row 处理 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 构建二级索引对应 dtuple_t *entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">entry</span> <span class="o">=</span> <span class="n">row_build_index_entry</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 字符集（非binary）比较输入目标 ientry 和主键二级索引部分是否一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="n">dtuple_coll_eq</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">ientry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">v_heap</span><span class="p">)</span> <span class="p">{</span> <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">v_heap</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存在 virtual row 处理 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">version</span> <span class="o">=</span> <span class="n">rec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查是否存在非 delete_mark 的老版本 rec 和二级索引匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap2</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span> <span class="o">=</span> <span class="n">mem_heap_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vrow</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 构建前一个版本行记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">trx_undo_prev_version_build</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">rec</span><span class="p">,</span> <span class="n">mtr</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="n">clust_offsets</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="k">nullptr</span><span class="p">,</span> <span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">vrow</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">heap2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_version</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 不存在更老的（purge 安全）版本 */</span>
</span></span><span class="line"><span class="cl">      <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">v_heap</span><span class="p">)</span> <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">v_heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">clust_offsets</span> <span class="o">=</span> <span class="n">rec_get_offsets</span><span class="p">(</span><span class="n">prev_version</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">ULINT_UNDEFINED</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* 存在 virtual row 处理 ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec_get_deleted_flag</span><span class="p">(</span><span class="n">prev_version</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">row_ext_t</span> <span class="o">*</span><span class="n">ext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">row</span> <span class="o">=</span> <span class="n">row_build</span><span class="p">(</span><span class="n">ROW_COPY_POINTERS</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="n">prev_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">clust_offsets</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ext</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span><span class="cm">/* 存在 virtual row 处理 ... */</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 构建二级索引对应 dtuple_t *entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">entry</span> <span class="o">=</span> <span class="n">row_build_index_entry</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* If entry == NULL, the record contains unset BLOB pointers.
</span></span></span><span class="line"><span class="cl"><span class="cm">        This cheated be a freshly inserted record that can ignore. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 字符集（非binary）比较输入目标 ientry 和主键二级索引部分是否一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="n">dtuple_coll_eq</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">ientry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">v_heap</span><span class="p">)</span> <span class="p">{</span> <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">v_heap</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">version</span> <span class="o">=</span> <span class="n">prev_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><strong>二级索引隐式锁判断</strong>
在做二级索引记录可见下判断时，当无法使用二级索引 page max tid 做过滤时，需要回表主键去检查是否存在一个活跃事务插入或修改了对应的二级索引记录。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* 查找是否存在 match/unmatch 的主键记录版本，
</span></span></span><span class="line"><span class="cl"><span class="cm">  目前如果 sec rec 是标记删除的则寻找是否有 match 的记录版本，
</span></span></span><span class="line"><span class="cl"><span class="cm">  如果 sec rec 是非标记删除的则去寻找是否有非 match 的记录版本 */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">row_vers_find_matching</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">looking_for_match</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dict_index_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">clust_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">clust_rec</span><span class="p">,</span> <span class="n">ulint</span> <span class="o">*&amp;</span><span class="n">clust_offsets</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dict_index_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">sec_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">sec_rec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ulint</span> <span class="o">*</span><span class="k">const</span> <span class="n">sec_offsets</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">comp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">trx_id_t</span> <span class="n">trx_id</span><span class="p">,</span> <span class="c1">// 当前 cluster rec 对应的 tid，必然是活跃的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mtr_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">mtr</span><span class="p">,</span> <span class="n">mem_heap_t</span> <span class="o">*&amp;</span><span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">version</span> <span class="o">=</span> <span class="n">clust_rec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_id_t</span> <span class="n">version_trx_id</span> <span class="o">=</span> <span class="n">trx_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 这里是回表到的当前索引上 cluster_rec 对应 tid 还活跃，但是 sec_rec 可能和不是这个 tid 产生的，仍要进一步判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 只需要寻找当前索引 cluster_rec 对应 tid 产生的记录，如果是更老的 tid 产生的这个 sec_rec，由于这个行记录可以被后续 tid 修改，其一定已经不活跃了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">version_trx_id</span> <span class="o">==</span> <span class="n">trx_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">old_heap</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">dtuple_t</span> <span class="o">*</span><span class="n">clust_vrow</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rec_t</span> <span class="o">*</span><span class="n">prev_version</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span> <span class="o">=</span> <span class="n">mem_heap_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 寻找前一个主键记录版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">trx_undo_prev_version_build</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">clust_rec</span><span class="p">,</span> <span class="n">mtr</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="n">clust_offsets</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">nullptr</span><span class="p">,</span> <span class="n">dict_index_has_virtual</span><span class="p">(</span><span class="n">sec_index</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">clust_vrow</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mem_heap_free</span><span class="p">(</span><span class="n">old_heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">version</span> <span class="o">=</span> <span class="n">prev_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">version_trx_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">clust_offsets</span> <span class="o">=</span> <span class="n">rec_get_offsets</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                      <span class="n">ULINT_UNDEFINED</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">version_trx_id</span> <span class="o">=</span> <span class="n">row_get_rec_trx_id</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">clust_index</span><span class="p">,</span> <span class="n">clust_offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ！这里需要判断是否由对应版本主键 prev version 到这个版本这次 “修改” 而产生的 sec_rec：
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">      sec_rec 是 non-delete marked（looking_for_match = false）：
</span></span></span><span class="line"><span class="cl"><span class="cm">        如果发现 prev version 是 delete mark 的或 version 二级索引部分与 sec_rec 不一致（不 match），
</span></span></span><span class="line"><span class="cl"><span class="cm">        说明是由这个版本 version 修改产生的这个 sec_rec（老版本被更新过），
</span></span></span><span class="line"><span class="cl"><span class="cm">        因此仍活跃。
</span></span></span><span class="line"><span class="cl"><span class="cm">      （sec_rec 活跃，prev version 非活跃 或 不一致 时，则说明对 prev version 的修改导致此 sec_rec 产生）
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">      sec_rec 是 delete marked（looking_for_match = true）：
</span></span></span><span class="line"><span class="cl"><span class="cm">        如果发现 prev version 是 非 delete mark 且 version 二级索引部分与 sec_rec 一致（match），
</span></span></span><span class="line"><span class="cl"><span class="cm">        说明是由这个版本 version 修改产生的这个 sec_rec（老版本被更新过），
</span></span></span><span class="line"><span class="cl"><span class="cm">        因此仍活跃。，
</span></span></span><span class="line"><span class="cl"><span class="cm">       （sec_rec 非活跃，prev version 活跃 且 一致 时，则说明对 prev version 的修改导致此 sec_rec 产生）
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">row_clust_vers_matches_sec</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">clust_index</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">clust_vrow</span><span class="p">,</span> <span class="n">clust_offsets</span><span class="p">,</span> <span class="n">sec_index</span><span class="p">,</span> <span class="n">sec_rec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">sec_offsets</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">looking_for_match</span><span class="p">,</span> <span class="n">heap</span><span class="p">)</span> <span class="o">==</span> <span class="n">looking_for_match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/mysql/">MySQL</a></li>
      <li><a href="https://mzyee.github.io/tags/undo/">Undo</a></li>
      <li><a href="https://mzyee.github.io/tags/mvcc/">MVCC</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://mzyee.github.io/posts/mysql/lock/">
    <span class="title">下一页 »</span>
    <br>
    <span>MySQL 事务锁系统</span>
  </a>
</nav>

  </footer>
<div>
  <div class="pagination__title">
    <span class="pagination__title-h" style="font-size: 20px;">💬 评论</span>
    <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.staticfile.org/twikoo/1.6.25/twikoo.all.min.js"></script>
  <script>
    twikoo.init({
      envId: "https://mzyeee.netlify.app/.netlify/functions/twikoo",  
      el: "#tcomment",
      lang: 'zh-CN',
      region: 'ap-hongkong',
      path: window.TWIKOO_MAGIC_PATH || window.location.pathname,
    });
  </script>
</div>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
