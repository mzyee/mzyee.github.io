<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL 事务锁系统 | MZY&#39;s Blog</title>
<meta name="keywords" content="MySQL, Lock, Transaction">
<meta name="description" content="MySQL 并发控制介绍和事务锁系统学习">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/mysql/lock/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.78ed8947c1508d00bdf7a3061370dcaebcd4ba680f4567ec440d26a4043b4e64.css" integrity="sha256-eO2JR8FQjQC996MGE3DcrrzUumgPRWfsRA0mpAQ7TmQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="MySQL 事务锁系统" />
<meta property="og:description" content="MySQL 并发控制介绍和事务锁系统学习" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/mysql/lock/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL 事务锁系统"/>
<meta name="twitter:description" content="MySQL 并发控制介绍和事务锁系统学习"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL",
      "item": "https://mzyee.github.io/posts/mysql/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "MySQL 事务锁系统",
      "item": "https://mzyee.github.io/posts/mysql/lock/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL 事务锁系统",
  "name": "MySQL 事务锁系统",
  "description": "MySQL 并发控制介绍和事务锁系统学习",
  "keywords": [
    "MySQL", "Lock", "Transaction"
  ],
  "articleBody": "1. 前言 数据库系统的并发控制与其多个模块相关联，其用于实现无冲突、保持一致性的多事务并发操作。并发控制模块需要保证事务并发执行的效果与要求的串行执行模式的效果完全相同，以达到隔离性的要求，不合理的并发控制可能导致更新丢失、不可重复读、脏读、幻读等问题。\n目前常用的并发控制协议可被粗略并不完整的分为悲观和乐观两大类：此处乐观协议指狭义乐观并发控制，如指基于完成有效性验证的并发控制，主要为前向 OCC 和后向 OCC 两类；而悲观协议又分为基于锁和非锁两大类，基于锁的协议有 2-Phase Locking、Altruistic Locking、Read/Write Tree Locking 等，非锁类协议有基于基于事务串行化图的协议等。此外，还可以进一步可以结合多版本并发控制（MVCC），以提高数据库的（读）性能。\n2. InnoDB 事务锁 2.1 两阶段锁（2PL Locking） 这里介绍最常用的为 2PL 协议，这也是 MySQL 使用的机制。2PL 将事务的执行阶段分为三个不同的部分：\n1）第一阶段，事务开始执行时，事务开始获取需要的锁的权限，但不释放锁； 2）第二部分是事务获取所有锁的过程； 3）当事务释放它的第一个锁时，第三阶段开始，此阶段事务不能要求任何新锁，只释放获取的锁。 从上可以看出 2PL 分为 Growing phase 和 Shrinking phase 两个阶段。根据锁定细节还可演化为 Conservative-2PL、Strict-2PL、Rigorous-2PL 等。2PL 协议提供了可序列化性，但不能保证不发生死锁，因此需要进行死锁预防或死锁检测。MySQL 采用的是死锁检测加超时恢复的机制，死锁检测一般通过 waits-for 图结构实现：图中点代表事务，有向边代表事务在等待另一个事务放锁，当 waits-for 图出现环时说明有死锁出现。此时需要进行死锁恢复，最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环，此时需要考虑如何选择回滚以避免饥饿并最小化代价。\n2.2 InnoDB 中的 Lock 目前 InnoDB 层主要有 LOCK_TABLE 和 LOCK_REC 两大类，后者提供更细粒度的锁操作。行锁以 scope 划分细节类型，有 LOCK_ORDINARY（next-key，记录及其前间隙的组合锁），LOCK_GAP（记录值的前间隙锁），LOCK_REC_NOT_GAP（单记录锁），LOCK_INSERT_INTENTION（为插入行为的gap锁）等。其次，行锁的锁定模式为 LOCK_IS、LOCK_IX、LOCK_S、LOCK_X、LOCK_AUTO_INC 等。\nInnoDB 的所有事务锁对象挂在全局对象 lock_sys_t 上，同时每个事务对象trx_t 上也维持了其拥有的事务锁，每个表对象 dict_table_t 上维持了其上的表级锁。8.0.21 版本还对 record hash 做 mutex 分片拆减少瓶颈。在一个系统中，每个表和每一行都可以被视作一种资源，并且事务在请求资源访问权限时会指定一个模式（mode），以表明它打算如何使用该资源。例如，LOCK_X 模式意味着事务需要排他性访问，而 LOCK_S 模式意味着事务可以与其他使用 LOCK_S 模式的事务共享资源，锁可以是等待状态（WAITING）或已授予状态（GRANTED）。锁系统使用页面编号（page_no，即包含记录的页面的标识符）和在页面内部分配记录数组中的位置（heap_no）来标识行记录。这在 b-tree 合并、分裂或可变长度记录的重新分配时变得很重要，这些操作都需要通知锁系统以反映变化。\n锁系统中的锁包含了元素：\n1）请求锁的事务（requesting transaction）；\n2）资源目标标识（特定的行或表定位）；\n3）锁类型与模式（如 LOCK_X、LOCK_S 等）；\n4）锁状态（WAITING 或 GRANTED）。\n锁的生命周期通常如下：\n1）事务请求锁，如果没有与现有锁冲突则立即授予（GRANTED），否则进入等待状态（WAITING）；\n2）若锁处于 WAITING 状态，则线程（主动）休眠；\n3）WAITING 锁要么在没有冲突的情况下变为 GRANTED，要么在回滚的情况下被取消，同时唤醒原先等待的事务线程；\n4）事务结束（提交或回滚）时释放其所有锁。\n行锁冲突关系通过函数 rec_lock_check_conflict 确定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 static inline Conflict rec_lock_check_conflict(const trx_t *trx, ulint type_mode, const lock_t *lock2, bool lock_is_on_supremum, Trx_locks_cache \u0026trx_locks_cache) { /* 锁模式的兼容矩阵 IS IX S X AI IS + + + - + IX + + - - + S + - + - - X - - - - - AI + + - - - Note that for rows, InnoDB only acquires S or X locks. For tables, InnoDB normally acquires IS or IX locks, S or X table locks are only acquired for LOCK TABLES. Auto-increment (AI) locks are needed because of statement-level MySQL binlog. */ /* 锁模式兼容 */ if (trx == lock2-\u003etrx || lock_mode_compatible(static_cast\u003clock_mode\u003e(LOCK_MODE_MASK \u0026 type_mode), lock_get_mode(lock2))) { return Conflict::NO_CONFLICT; } /* 这里需要注意一点，新来的锁是需要和对应锁链上所有相同资源目标的锁做兼容比较， 包括原先为 waiting 状态的锁，这样做防止了 X 锁饥饿的问题 */ const bool is_hp = trx_is_high_priority(trx); /* 高优先级是事务可以忽略原先的 waiting 状态的低优先级事务*/ if (is_hp \u0026\u0026 lock2-\u003eis_waiting() \u0026\u0026 !trx_is_high_priority(lock2-\u003etrx)) { return Conflict::NO_CONFLICT; } /* 要加的锁是 非insert_intention的 上界 或 gap 锁，可以兼容任何锁 */ if ((lock_is_on_supremum || (type_mode \u0026 LOCK_GAP)) \u0026\u0026 !(type_mode \u0026 LOCK_INSERT_INTENTION)) { return Conflict::NO_CONFLICT; } /* 要加 非insert_intention的锁，可以兼容 gap 锁 */ if (!(type_mode \u0026 LOCK_INSERT_INTENTION) \u0026\u0026 lock_rec_get_gap(lock2)) { return Conflict::NO_CONFLICT; } /* 要加的锁是 gap 锁，可以和 rec_not_gap 兼容 */ if ((type_mode \u0026 LOCK_GAP) \u0026\u0026 lock_rec_get_rec_not_gap(lock2)) { return Conflict::NO_CONFLICT; } /* 锁链上待比较的锁是 insert_intention 的，可以兼容其他锁 */ if (lock_rec_get_insert_intention(lock2)) { return Conflict::NO_CONFLICT; } /* insert_intention 锁最大的问题是后续插入后会把 lock 区间分裂， 并由单个 lock 产生两个 lock，这样就有可能导致事务 waiting 状态的 gap 或 next-key lock 变成两个 waiting 状态的 lock，违背事务最 多一个 waiting lock 的原则 */ if (!(type_mode \u0026 LOCK_INSERT_INTENTION) \u0026\u0026 lock2-\u003eis_waiting() \u0026\u0026 lock2-\u003emode() == LOCK_X \u0026\u0026 (type_mode \u0026 LOCK_MODE_MASK) == LOCK_X) { /* 如果 waiting 状态的锁是被当前 trx 自己已经 granted 的锁给阻塞，则不需要等这个 waiting 状态的锁 */ if (trx_locks_cache.has_granted_blocker(trx, lock2)) { return Conflict::CAN_BYPASS; } } return Conflict::HAS_TO_WAIT; } 2.2 加锁逻辑（案例） 以 sysbench 表结构为例，介绍写入时的加锁逻辑。\n1 2 3 4 5 6 7 8 CREATE TABLE `sbtest1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `k` int(11) NOT NULL DEFAULT '0', `c` char(120) NOT NULL DEFAULT '', `pad` char(60) NOT NULL DEFAULT '', PRIMARY KEY (`id`), KEY `k_1` (`k`) ) ENGINE=InnoDB; 这里先额外说明一下 innodb 在加行锁时一定 cursor 已经定位了（为了确定资源目标标识，即 page_id 和 heap_no），并且获得了 page 页面锁以防止修改。\n首先讨论 insert 场景，insert 流程先主键（row_ins_clust_index_entry）再二级索引（row_ins_sec_index_entry），在每个索引上执行的操作步骤类似：\n定位 cursor 至目标位置（这里还可以获得定位匹配情况）； a）如果是唯一索引（包括主键），并且定位时发现和目标索引上存在 record 和将要插入的记录物理 match，则要走到 record 判重逻辑中（row_ins_duplicate_error_in_clust / row_ins_scan_sec_index_for_duplicate），其中会先对应去加目标行的行锁（lock_clust_rec_read_check_and_lock / lock_sec_rec_read_check_and_lock 两个函数的执行逻辑基本一致），这里可能产生锁等待，再判断重复性是否满足要求； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 dberr_t lock_clust_rec_read_check_and_lock( const lock_duration_t duration, const buf_block_t *block, const rec_t *rec, dict_index_t *index, const ulint *offsets, const select_mode sel_mode, const lock_mode mode, const ulint gap_mode, que_thr_t *thr) { if (srv_read_only_mode || index-\u003etable-\u003eis_temporary()) return (DB_SUCCESS); dberr_t err; ulint heap_no = page_rec_get_heap_no(rec); // 隐式锁判断：通过 \"主键record上面的系统列\" 和 \"活跃事务数组\" 判断对应记录是否存在隐式锁，如有则为其加上显示锁 // 判断二级索引无法过滤时，需要回表 if (heap_no != PAGE_HEAP_NO_SUPREMUM) { lock_rec_convert_impl_to_expl(block, rec, index, offsets); } { locksys::Shard_latch_guard guard{UT_LOCATION_HERE, block-\u003eget_page_id()}; if (duration == lock_duration_t::AT_LEAST_STATEMENT) { lock_protect_locks_till_statement_end(thr); } // 加行锁，不可为隐式锁 err = lock_rec_lock(false, sel_mode, mode | gap_mode, block, heap_no, index, thr); } return (err); } b）如果是非唯一索引，或者未发现已存在匹配 record，则在 insert 阶段可以跳过重复性检查（进而这里也不再需要走加锁逻辑）； 3. 进行真正的插入操作（btr_cur_optimistic_update / btr_cur_pessimistic_update 这两个接口为通过修改插入； btr_cur_optimistic_insert / btr_cur_pessimistic_insert 这两个接口为直接插入），其中会对应进行行锁操作 （lock_clust_rec_modify_check_and_lock / lock_sec_rec_modify_check_and_lock 通过修改插入； lock_rec_insert_check_and_lock 直接插入）：\n修改插入（update）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 dberr_t lock_clust_rec_modify_check_and_lock( ulint flags, /*!\u003c in: if BTR_NO_LOCKING_FLAG bit is set, does nothing */ const buf_block_t *block, /*!\u003c in: buffer block of rec */ const rec_t *rec, /*!\u003c in: record which should be modified */ dict_index_t *index, /*!\u003c in: clustered index */ const ulint *offsets, /*!\u003c in: rec_get_offsets(rec, index) */ que_thr_t *thr) /*!\u003c in: query thread */ { if (flags \u0026 BTR_NO_LOCKING_FLAG) return (DB_SUCCESS); dberr_t err; ulint heap_no = rec_offs_comp(offsets) ? rec_get_heap_no_new(rec) : rec_get_heap_no_old(rec); // 隐式锁判断：通过 \"主键record上面的系统列\" 和 \"活跃事务数组\" 判断对应记录是否存在隐式锁，如有则为其加上显示锁； // 判断二级索引无法过滤时，需要回表 lock_rec_convert_impl_to_expl(block, rec, index, offsets); { locksys::Shard_latch_guard guard{UT_LOCATION_HERE, block-\u003eget_page_id()}; // 加行锁，可为隐式锁，即无冲突时不真正加行锁 err = lock_rec_lock(true, SELECT_ORDINARY, LOCK_X | LOCK_REC_NOT_GAP, block, heap_no, index, thr); } if (err == DB_SUCCESS_LOCKED_REC) err = DB_SUCCESS; return (err); } 直接插入（insert）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 dberr_t lock_rec_insert_check_and_lock( ulint flags, /*!\u003c in: if BTR_NO_LOCKING_FLAG bit is set, does nothing */ const rec_t *rec, /*!\u003c in: record after which to insert */ buf_block_t *block, /*!\u003c in/out: buffer block of rec */ dict_index_t *index, /*!\u003c in: index */ que_thr_t *thr, /*!\u003c in: query thread */ mtr_t *mtr, /*!\u003c in/out: mini-transaction */ bool *inherit) /*!\u003c out: set to true if the new inserted record maybe should inherit LOCK_GAP locks from successor record */ { if (flags \u0026 BTR_NO_LOCKING_FLAG) return (DB_SUCCESS); dberr_t err = DB_SUCCESS; lock_t *lock; auto inherit_in = *inherit; trx_t *trx = thr_get_trx(thr); const rec_t *next_rec = page_rec_get_next_const(rec); ulint heap_no = page_rec_get_heap_no(next_rec); { locksys::Shard_latch_guard guard{UT_LOCATION_HERE, block-\u003eget_page_id()}; if (lock_rec_get_first(lock_sys-\u003erec_hash, block, heap_no) == nullptr) { // 锁链上无锁，直接加隐式锁 *inherit = false; } else { *inherit = true; const ulint type_mode = LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION; // 判断锁链上是否存在冲突模式的锁：如果存在其他后继记录的除 insert 目的外的 gap 锁 const auto conflicting = lock_rec_other_has_conflicting(type_mode, block, heap_no, trx); if (conflicting.wait_for != nullptr) { RecLock rec_lock(thr, index, block, heap_no, type_mode); trx_mutex_enter(trx); // 存在冲突，加行锁 err = rec_lock.add_to_waitq(conflicting.wait_for); trx_mutex_exit(trx); } } } switch (err) { case DB_SUCCESS_LOCKED_REC: err = DB_SUCCESS; case DB_SUCCESS: if (!inherit_in || index-\u003eis_clustered()) break; /* 二级索引更新 page 上的 max trx id 标志 */ page_update_max_trx_id(block, buf_block_get_page_zip(block), trx-\u003eid, mtr); default: break; } return (err); } 更多隐式锁相关内容可以参考这篇 mysql 月报文章。\nupdate 流程会先通过读接口来寻找原先需要被更新的行记录（index_read-\u003erow_search_mvcc），在读阶段就会对目标行进行加锁（lock_clust_rec_read_check_and_lock / lock_sec_rec_read_check_and_lock），这里的加锁接口和 insert 判重阶段一致，具体加锁模式还和隔离级别有关。 update 第二个阶段会真正去修改数据，也有直接 update 模式和 delete_mark + insert 模式，到 btr_cur_ 层的接口一致，因此加锁函数接口也一致。\n2.3 锁的释放 大多数情况下事务持有的所有锁（trx_t::lock.trx_locks）都是在事务提交时释放(trx_release_impl_and_expl_locks-\u003elock_trx_release_locks，在 trx_commit_in_memory 阶段的开始)。有两个例外：\na）AUTO-INC 锁（由参数 innodb_autoinc_lock_mode 控制）在SQL结束时直接释放（innobase_commit –\u003e lock_unlock_table_autoinc）；\nb）在 RC 隔离级别下执行 DML 语句时，从引擎层返回到 Server 层的记录，如果不满足 where 条件，则会立刻 unlock 掉（ha_innobase::unlock_row）。\n对于行锁，从 lock sys hash 中删除后还需要判断是否有正在等待的会话可以被唤醒（lock_rec_dequeue_from_page）。这里采用的是 CATS 策略将所有处于 LOCK_WAIT 状态的锁对象按trx优先权、调度权重 trx-\u003elock.schedule_weight 排序，然后依次处理。对于每个等待状态的锁对象，如果其不再等待任何已有 granted 的锁对象（包括这次循环前面 grant 的），则清理等待事务的相关锁等待状态并唤醒线程已经挂起的等待事务；反之，则更新等待关系、继续等待。\n2.4 死锁检测及CATS策略 官方在 Bug#29882690: UNDETECTED DEADLOCK WITH GAP AND INSERT INTENTION LOCKS IS POSSIBLE 中修复部分原先无法探测的死锁，还将锁阻塞信息（wait-for图）从 lock 转移到 trx 中，并且将死锁检测从前台事务线程转移到后台监控线程。这样减轻了前台事务线程的取锁冲突时的检测代价；但是死锁会先进入事务系统，后续检测出后回滚，也就意味着死锁事务会占用一段时间的线程、内存资源、导致锁链、事务数组等的膨胀后（对应线程先进入、然后 suspend 进入睡眠等待后）才会被回滚，若是死锁概率较高的高冲突场景这可能会导致整体事务系统的性能下降。死锁处理的逻辑在 lock_wait_timeout_thread 线程中（lock_wait_update_schedule_and_check_for_deadlocks），顾名思义这个函数更新了事务权重比检查了是否存在死锁。新版死锁检测逻辑的理论基础可以参考这篇 mysql 月报文章，下面主要介绍代码逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** Takes a snapshot of transactions in waiting currently in slots, updates their schedule weights, searches for deadlocks among them and resolves them. */ static void lock_wait_update_schedule_and_check_for_deadlocks() { ut::vector\u003cwaiting_trx_info_t\u003e infos; ut::vector\u003cint\u003e outgoing; ut::vector\u003ctrx_schedule_weight_t\u003e new_weights; /* （以下持有 lock_sys-\u003ewait_mutex） 将 lock_sys 中所有 waiting 状态的 trx 及阻塞它的 blocking_trx 加入到 infos，构建 wait trx 的 snapshot； */ auto table_reservations = lock_wait_snapshot_waiting_threads(infos); /* 构建 waiting for graph，实质上就是寻找某个 trx 的 blocking_trx 是否存在在 info 中， blocking_trx 也存在的话通过 outgoing 数组关联位置起来，这样就将所有依赖的 trx 串联起来， (即将这个 trx 在 info 中的 index 位置作为 outgoing index， 将 blocking_trx 在 info 中的 index 位置作为 outgoing 中这个 index 对应位置的元素） */ lock_wait_build_wait_for_graph(infos, outgoing); /* 初始化事务权重值，正常等待事务初始为1，超时事务会初始为较大值； 通过关联树图算出 new_weights（依赖子树元素数目）： 将所有无入度的节点入栈，再遍历栈元素根据其出度确定父节点并将这个子节点的权重增加到父节点上，并减少其父节点入度计数； 如果对应父节点还存在有出度，当其所有入度处理完成后（入度计数为0，其所有入度已经转化为权重值），作为无入度节点入栈同上处理； 直到栈中无任何元素（不存在还有出度的元素） NOTE：如果有环存在，其上一定不存在无入度的节点，因此不会在上述步骤处理，因此入度计数不为0 将除死锁环外的所有等待状态的事务权重更新（持有 lock_sys-\u003ewait_mutex） */ lock_wait_compute_and_publish_weights_except_cycles(infos, table_reservations, outgoing, new_weights); if (innobase_deadlock_detect) { /* 用 DFS 方式确定的一个死锁环，如果存在的话就选择目标并回滚事务（lock_cancel_waiting_and_release） */ lock_wait_find_and_handle_deadlocks(infos, outgoing, new_weights); } } CATS 策略基于后台生产的事务权重，在事务放锁选择最合适等待事务去唤醒，提升整体事务效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 static void lock_rec_grant_by_heap_no(lock_t *in_lock, ulint heap_no) { const auto hash_table = in_lock-\u003ehash_table(); using LockDescriptorEx = std::pair\u003ctrx_schedule_weight_t, lock_t *\u003e; Scoped_heap heap((sizeof(lock_t *) * 3 + sizeof(LockDescriptorEx)) * 32, UT_LOCATION_HERE); RecID rec_id{in_lock, heap_no}; Locks\u003clock_t *\u003e low_priority_light{heap.get()}; Locks\u003clock_t *\u003e waiting{heap.get()}; Locks\u003clock_t *\u003e granted{heap.get()}; Locks\u003cLockDescriptorEx\u003e low_priority_heavier{heap.get()}; const auto in_trx = in_lock-\u003etrx; /* 对于锁链上每个 lock 划分到 granted、waiting、low_priority_light、low_priority_heavier 中： granted: 已经获取到的锁，如果等待锁被授权，也会从 waiting 转移到 granted； low_priority_light：低权重的 waiting 状态锁； low_priority_heavier：高权重的 waiting 状态锁； waiting：处于 waiting 状态的锁，最终 low_priority_light 和 low_priority_heavier 会合并入此数组； */ Lock_iter::for_each(rec_id, [\u0026](lock_t *lock) { if (!lock-\u003eis_waiting()) { granted.push_back(lock); return (true); } const auto trx = lock-\u003etrx; if (trx-\u003eerror_state == DB_DEADLOCK || trx-\u003elock.was_chosen_as_deadlock_victim) { return (true); } const auto blocking_trx = trx-\u003elock.blocking_trx.load(std::memory_order_relaxed); if (blocking_trx != in_trx) { return (true); } if (trx_is_high_priority(trx)) { waiting.push_back(lock); return (true); } /* 这个等待的事务还有等待它的事务，认为是高权重 */ const auto schedule_weight = trx-\u003elock.schedule_weight.load(std::memory_order_relaxed); if (schedule_weight \u003c= 1) { low_priority_light.push_back(lock); } else { low_priority_heavier.push_back(LockDescriptorEx{schedule_weight, lock}); } return (true); }, hash_table); if (waiting.empty() \u0026\u0026 low_priority_light.empty() \u0026\u0026 low_priority_heavier.empty()) { return; } /* 按权重进行排序，高权重优先 grant */ std::stable_sort(low_priority_heavier.begin(), low_priority_heavier.end(), [](const LockDescriptorEx \u0026a, const LockDescriptorEx \u0026b) { return (a.first \u003e b.first);}); for (const auto \u0026descriptor : low_priority_heavier) {waiting.push_back(descriptor.second);} waiting.insert(waiting.end(), low_priority_light.begin(), low_priority_light.end()); const auto new_granted_index = granted.size(); granted.reserve(granted.size() + waiting.size()); for (lock_t *wait_lock : waiting) { /* 已授权锁是否会阻塞当前锁 */ const lock_t *blocking_lock = lock_rec_has_to_wait_for_granted(wait_lock, granted, new_granted_index); if (blocking_lock == nullptr) { lock_grant(wait_lock); lock_rec_move_granted_to_front(wait_lock, rec_id); granted.push_back(wait_lock); } else { /* 等待的锁等待原因可能改变，更新 wait_for 图 */ lock_update_wait_for_edge(wait_lock, blocking_lock); } } } 版权声明：如需转载或引用，请附加本文链接并注明来源。 ",
  "wordCount" : "1589",
  "inLanguage": "zh",
  "datePublished": "2023-12-05T00:00:00Z",
  "dateModified": "2023-12-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/mysql/lock/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title=" MZY&#39;s Blog (Alt + H)">
                <img src="https://mzyee.github.io/img/eye.jpg" alt="" aria-label="logo"
                    height="38"> MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/mysql/">MySQL</a></div>
    <h1 class="post-title">
      MySQL 事务锁系统
    </h1>
    <div class="post-meta"><span title='2023-12-05 00:00:00 +0000 UTC'>十二月 5, 2023</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;Miao Zheyu
      &nbsp;|&nbsp;📖 &nbsp;
      <ul class="post-tags-meta">
        <a href="https://mzyee.github.io/tags/mysql/">MySQL</a>
        <a href="https://mzyee.github.io/tags/lock/">&nbsp;Lock</a>
        <a href="https://mzyee.github.io/tags/transaction/">&nbsp;Transaction</a>
      </ul>&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e5%89%8d%e8%a8%80" aria-label="1. 前言">1. 前言</a></li>
                    <li>
                        <a href="#2-innodb-%e4%ba%8b%e5%8a%a1%e9%94%81" aria-label="2. InnoDB 事务锁">2. InnoDB 事务锁</a><ul>
                            
                    <li>
                        <a href="#21-%e4%b8%a4%e9%98%b6%e6%ae%b5%e9%94%812pl-locking" aria-label="2.1 两阶段锁（2PL Locking）">2.1 两阶段锁（2PL Locking）</a></li>
                    <li>
                        <a href="#22-innodb-%e4%b8%ad%e7%9a%84-lock" aria-label="2.2 InnoDB 中的 Lock">2.2 InnoDB 中的 Lock</a></li>
                    <li>
                        <a href="#22-%e5%8a%a0%e9%94%81%e9%80%bb%e8%be%91%e6%a1%88%e4%be%8b" aria-label="2.2 加锁逻辑（案例）">2.2 加锁逻辑（案例）</a></li>
                    <li>
                        <a href="#23-%e9%94%81%e7%9a%84%e9%87%8a%e6%94%be" aria-label="2.3 锁的释放">2.3 锁的释放</a></li>
                    <li>
                        <a href="#24-%e6%ad%bb%e9%94%81%e6%a3%80%e6%b5%8b%e5%8f%8acats%e7%ad%96%e7%95%a5" aria-label="2.4 死锁检测及CATS策略">2.4 死锁检测及CATS策略</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><h3 id="1-前言">1. 前言<a hidden class="anchor" aria-hidden="true" href="#1-前言">#</a></h3>
<p>   数据库系统的并发控制与其多个模块相关联，其用于实现无冲突、保持一致性的多事务并发操作。并发控制模块需要保证事务并发执行的效果与要求的串行执行模式的效果完全相同，以达到隔离性的要求，不合理的并发控制可能导致更新丢失、不可重复读、脏读、幻读等问题。</p>
<center><img src="cc.png" width="70%" /></center>
<p>   目前常用的并发控制协议可被粗略并不完整的分为悲观和乐观两大类：此处乐观协议指狭义乐观并发控制，如指基于<em>完成有效性验证</em>的并发控制，主要为前向 OCC 和后向 OCC 两类；而悲观协议又分为基于锁和非锁两大类，<em>基于锁的协议</em>有 2-Phase Locking、Altruistic Locking、Read/Write Tree Locking 等，<em>非锁类协议</em>有基于基于事务串行化图的协议等。此外，还可以进一步可以结合多版本并发控制（MVCC），以提高数据库的（读）性能。</p>
<h3 id="2-innodb-事务锁">2. InnoDB 事务锁<a hidden class="anchor" aria-hidden="true" href="#2-innodb-事务锁">#</a></h3>
<h4 id="21-两阶段锁2pl-locking">2.1 两阶段锁（2PL Locking）<a hidden class="anchor" aria-hidden="true" href="#21-两阶段锁2pl-locking">#</a></h4>
<p>   这里介绍最常用的为 2PL 协议，这也是 MySQL 使用的机制。2PL 将事务的执行阶段分为三个不同的部分：</p>
<ul>
<li>1）第一阶段，事务开始执行时，事务开始获取需要的锁的权限，但不释放锁；</li>
<li>2）第二部分是事务获取所有锁的过程；</li>
<li>3）当事务释放它的第一个锁时，第三阶段开始，此阶段事务不能要求任何新锁，只释放获取的锁。</li>
</ul>
<p>   从上可以看出 2PL 分为 Growing phase 和 Shrinking phase 两个阶段。根据锁定细节还可演化为 Conservative-2PL、Strict-2PL、Rigorous-2PL 等。2PL 协议提供了可序列化性，但不能保证不发生死锁，因此需要进行死锁预防或死锁检测。MySQL 采用的是死锁检测加超时恢复的机制，死锁检测一般通过 waits-for 图结构实现：图中点代表事务，有向边代表事务在等待另一个事务放锁，当 waits-for 图出现环时说明有死锁出现。此时需要进行死锁恢复，最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环，此时需要考虑如何选择回滚以避免饥饿并最小化代价。</p>
<h4 id="22-innodb-中的-lock">2.2 InnoDB 中的 Lock<a hidden class="anchor" aria-hidden="true" href="#22-innodb-中的-lock">#</a></h4>
<p>   目前 InnoDB 层主要有 LOCK_TABLE 和 LOCK_REC 两大类，后者提供更细粒度的锁操作。行锁以 scope 划分细节类型，有 <em>LOCK_ORDINARY</em>（next-key，记录及其前间隙的组合锁），<em>LOCK_GAP</em>（记录值的前间隙锁），<em>LOCK_REC_NOT_GAP</em>（单记录锁），<em>LOCK_INSERT_INTENTION</em>（为插入行为的gap锁）等。其次，行锁的锁定模式为 <em>LOCK_IS</em>、<em>LOCK_IX</em>、<em>LOCK_S</em>、<em>LOCK_X</em>、<em>LOCK_AUTO_INC</em> 等。</p>
<p>   InnoDB 的所有事务锁对象挂在全局对象 lock_sys_t 上，同时每个事务对象trx_t 上也维持了其拥有的事务锁，每个表对象 dict_table_t 上维持了其上的表级锁。8.0.21 版本还对 record hash 做 mutex 分片拆减少瓶颈。在一个系统中，每个表和每一行都可以被视作一种资源，并且事务在请求资源访问权限时会指定一个模式（mode），以表明它打算如何使用该资源。例如，LOCK_X 模式意味着事务需要排他性访问，而 LOCK_S 模式意味着事务可以与其他使用 LOCK_S 模式的事务共享资源，锁可以是等待状态（WAITING）或已授予状态（GRANTED）。锁系统使用页面编号（page_no，即包含记录的页面的标识符）和在页面内部分配记录数组中的位置（heap_no）来标识行记录。这在 b-tree 合并、分裂或可变长度记录的重新分配时变得很重要，这些操作都需要通知锁系统以反映变化。</p>
<p>   锁系统中的锁包含了元素：<br>
1）请求锁的事务（requesting transaction）；<br>
2）资源目标标识（特定的行或表定位）；<br>
3）锁类型与模式（如 LOCK_X、LOCK_S 等）；<br>
4）锁状态（WAITING 或 GRANTED）。</p>
<p>   锁的生命周期通常如下：<br>
1）事务请求锁，如果没有与现有锁冲突则立即授予（GRANTED），否则进入等待状态（WAITING）；<br>
2）若锁处于 WAITING 状态，则线程（主动）休眠；<br>
3）WAITING 锁要么在没有冲突的情况下变为 GRANTED，要么在回滚的情况下被取消，同时唤醒原先等待的事务线程；<br>
4）事务结束（提交或回滚）时释放其所有锁。</p>
<p>   行锁冲突关系通过函数 <code>rec_lock_check_conflict</code> 确定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="n">Conflict</span> <span class="nf">rec_lock_check_conflict</span><span class="p">(</span><span class="k">const</span> <span class="n">trx_t</span> <span class="o">*</span><span class="n">trx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">type_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">lock_t</span> <span class="o">*</span><span class="n">lock2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">lock_is_on_supremum</span><span class="p">,</span> <span class="n">Trx_locks_cache</span> <span class="o">&amp;</span><span class="n">trx_locks_cache</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 锁模式的兼容矩阵
</span></span></span><span class="line"><span class="cl"><span class="cm">        IS   IX   S   X   AI
</span></span></span><span class="line"><span class="cl"><span class="cm">    IS  +    +    +   -   +
</span></span></span><span class="line"><span class="cl"><span class="cm">    IX  +    +    -   -   +
</span></span></span><span class="line"><span class="cl"><span class="cm">    S   +    -    +   -   -
</span></span></span><span class="line"><span class="cl"><span class="cm">    X   -    -    -   -   -
</span></span></span><span class="line"><span class="cl"><span class="cm">    AI  +    +    -   -   -
</span></span></span><span class="line"><span class="cl"><span class="cm">    Note that for rows, InnoDB only acquires S or X locks.
</span></span></span><span class="line"><span class="cl"><span class="cm">    For tables, InnoDB normally acquires IS or IX locks,
</span></span></span><span class="line"><span class="cl"><span class="cm">    S or X table locks are only acquired for LOCK TABLES.
</span></span></span><span class="line"><span class="cl"><span class="cm">    Auto-increment (AI) locks are needed because of
</span></span></span><span class="line"><span class="cl"><span class="cm">    statement-level MySQL binlog.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 锁模式兼容 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">trx</span> <span class="o">==</span> <span class="n">lock2</span><span class="o">-&gt;</span><span class="n">trx</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock_mode_compatible</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">lock_mode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LOCK_MODE_MASK</span> <span class="o">&amp;</span> <span class="n">type_mode</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                           <span class="n">lock_get_mode</span><span class="p">(</span><span class="n">lock2</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 这里需要注意一点，新来的锁是需要和对应锁链上所有相同资源目标的锁做兼容比较，
</span></span></span><span class="line"><span class="cl"><span class="cm">     包括原先为 waiting 状态的锁，这样做防止了 X 锁饥饿的问题 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">bool</span> <span class="n">is_hp</span> <span class="o">=</span> <span class="n">trx_is_high_priority</span><span class="p">(</span><span class="n">trx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 高优先级是事务可以忽略原先的 waiting 状态的低优先级事务*/</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">is_hp</span> <span class="o">&amp;&amp;</span> <span class="n">lock2</span><span class="o">-&gt;</span><span class="n">is_waiting</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trx_is_high_priority</span><span class="p">(</span><span class="n">lock2</span><span class="o">-&gt;</span><span class="n">trx</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 要加的锁是 非insert_intention的 上界 或 gap 锁，可以兼容任何锁 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">lock_is_on_supremum</span> <span class="o">||</span> <span class="p">(</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_GAP</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="p">(</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_INSERT_INTENTION</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 要加 非insert_intention的锁，可以兼容 gap 锁 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_INSERT_INTENTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lock_rec_get_gap</span><span class="p">(</span><span class="n">lock2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 要加的锁是 gap 锁，可以和 rec_not_gap 兼容 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_GAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lock_rec_get_rec_not_gap</span><span class="p">(</span><span class="n">lock2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 锁链上待比较的锁是 insert_intention 的，可以兼容其他锁 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">lock_rec_get_insert_intention</span><span class="p">(</span><span class="n">lock2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">NO_CONFLICT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* insert_intention 锁最大的问题是后续插入后会把 lock 区间分裂，
</span></span></span><span class="line"><span class="cl"><span class="cm">     并由单个 lock 产生两个 lock，这样就有可能导致事务 waiting 状态的
</span></span></span><span class="line"><span class="cl"><span class="cm">     gap 或 next-key lock 变成两个 waiting 状态的 lock，违背事务最
</span></span></span><span class="line"><span class="cl"><span class="cm">     多一个 waiting lock 的原则 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_INSERT_INTENTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lock2</span><span class="o">-&gt;</span><span class="n">is_waiting</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock2</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">()</span> <span class="o">==</span> <span class="n">LOCK_X</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type_mode</span> <span class="o">&amp;</span> <span class="n">LOCK_MODE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">LOCK_X</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果 waiting 状态的锁是被当前 trx 自己已经 granted 的锁给阻塞，则不需要等这个 waiting 状态的锁 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">trx_locks_cache</span><span class="p">.</span><span class="n">has_granted_blocker</span><span class="p">(</span><span class="n">trx</span><span class="p">,</span> <span class="n">lock2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">CAN_BYPASS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Conflict</span><span class="o">::</span><span class="n">HAS_TO_WAIT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><!-- <div align=center>
<div class="mermaid">
  


</div>

</div> -->
<h4 id="22-加锁逻辑案例">2.2 加锁逻辑（案例）<a hidden class="anchor" aria-hidden="true" href="#22-加锁逻辑案例">#</a></h4>
<p>   以 sysbench 表结构为例，介绍写入时的加锁逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">sbtest1</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">k</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="nb">char</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="k">pad</span><span class="o">`</span><span class="w"> </span><span class="nb">char</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">k_1</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">k</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>   这里先额外说明一下 innodb 在加行锁时一定 <strong>cursor 已经定位了</strong>（为了确定资源目标标识，即 page_id 和 heap_no），并且获得了 page 页面锁以防止修改。</p>
<p>   首先讨论 insert 场景，insert 流程先主键（row_ins_clust_index_entry）再二级索引（row_ins_sec_index_entry），在每个索引上执行的操作步骤类似：</p>
<ol>
<li>定位 cursor 至目标位置（这里还可以获得定位匹配情况）；</li>
<li>a）如果是唯一索引（包括主键），并且定位时发现和目标索引上存在 record 和将要插入的记录物理 match，则要走到 record 判重逻辑中（row_ins_duplicate_error_in_clust / row_ins_scan_sec_index_for_duplicate），其中会先对应去加目标行的行锁（<strong>lock_clust_rec_read_check_and_lock</strong> / <strong>lock_sec_rec_read_check_and_lock</strong> 两个函数的执行逻辑基本一致），这里可能产生锁等待，再判断重复性是否满足要求；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">lock_clust_rec_read_check_and_lock</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">lock_duration_t</span> <span class="n">duration</span><span class="p">,</span> <span class="k">const</span> <span class="n">buf_block_t</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">ulint</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">select_mode</span> <span class="n">sel_mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">lock_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">ulint</span> <span class="n">gap_mode</span><span class="p">,</span> <span class="n">que_thr_t</span> <span class="o">*</span><span class="n">thr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">srv_read_only_mode</span> <span class="o">||</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">is_temporary</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">DB_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">dberr_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">heap_no</span> <span class="o">=</span> <span class="n">page_rec_get_heap_no</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 隐式锁判断：通过 &#34;主键record上面的系统列&#34; 和 &#34;活跃事务数组&#34; 判断对应记录是否存在隐式锁，如有则为其加上显示锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//           判断二级索引无法过滤时，需要回表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">heap_no</span> <span class="o">!=</span> <span class="n">PAGE_HEAP_NO_SUPREMUM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock_rec_convert_impl_to_expl</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">locksys</span><span class="o">::</span><span class="n">Shard_latch_guard</span> <span class="n">guard</span><span class="p">{</span><span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">get_page_id</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">duration</span> <span class="o">==</span> <span class="n">lock_duration_t</span><span class="o">::</span><span class="n">AT_LEAST_STATEMENT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock_protect_locks_till_statement_end</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加行锁，不可为隐式锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">lock_rec_lock</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">sel_mode</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">gap_mode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">heap_no</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>b）如果是非唯一索引，或者未发现已存在匹配 record，则在 insert 阶段可以跳过重复性检查（进而这里也不再需要走加锁逻辑）；
3. 进行真正的插入操作（btr_cur_optimistic_update / btr_cur_pessimistic_update 这两个接口为通过修改插入； btr_cur_optimistic_insert / btr_cur_pessimistic_insert 这两个接口为直接插入），其中会对应进行行锁操作 （<strong>lock_clust_rec_modify_check_and_lock</strong> / <strong>lock_sec_rec_modify_check_and_lock</strong> 通过修改插入； <strong>lock_rec_insert_check_and_lock</strong> 直接插入）：<br>
<strong>修改插入（update）：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">lock_clust_rec_modify_check_and_lock</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">ulint</span> <span class="n">flags</span><span class="p">,</span>              <span class="cm">/*!&lt; in: if BTR_NO_LOCKING_FLAG
</span></span></span><span class="line"><span class="cl"><span class="cm">                              bit is set, does nothing */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">buf_block_t</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="cm">/*!&lt; in: buffer block of rec */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>         <span class="cm">/*!&lt; in: record which should be
</span></span></span><span class="line"><span class="cl"><span class="cm">                              modified */</span>
</span></span><span class="line"><span class="cl">    <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>      <span class="cm">/*!&lt; in: clustered index */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ulint</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span>     <span class="cm">/*!&lt; in: rec_get_offsets(rec, index)</span> <span class="err">*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">que_thr_t</span> <span class="o">*</span><span class="n">thr</span><span class="p">)</span>           <span class="cm">/*!&lt; in: query thread */</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTR_NO_LOCKING_FLAG</span><span class="p">)</span>  <span class="k">return</span> <span class="p">(</span><span class="n">DB_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">dberr_t</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">heap_no</span> <span class="o">=</span> <span class="n">rec_offs_comp</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">?</span> <span class="n">rec_get_heap_no_new</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                         <span class="o">:</span> <span class="n">rec_get_heap_no_old</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 隐式锁判断：通过 &#34;主键record上面的系统列&#34; 和 &#34;活跃事务数组&#34; 判断对应记录是否存在隐式锁，如有则为其加上显示锁；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//           判断二级索引无法过滤时，需要回表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">lock_rec_convert_impl_to_expl</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">locksys</span><span class="o">::</span><span class="n">Shard_latch_guard</span> <span class="n">guard</span><span class="p">{</span><span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">get_page_id</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加行锁，可为隐式锁，即无冲突时不真正加行锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">lock_rec_lock</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">SELECT_ORDINARY</span><span class="p">,</span> <span class="n">LOCK_X</span> <span class="o">|</span> <span class="n">LOCK_REC_NOT_GAP</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">heap_no</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">DB_SUCCESS_LOCKED_REC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">DB_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>直接插入（insert）：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">lock_rec_insert_check_and_lock</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">ulint</span> <span class="n">flags</span><span class="p">,</span>         <span class="cm">/*!&lt; in: if BTR_NO_LOCKING_FLAG bit is
</span></span></span><span class="line"><span class="cl"><span class="cm">                         set, does nothing */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>    <span class="cm">/*!&lt; in: record after which to insert */</span>
</span></span><span class="line"><span class="cl">    <span class="n">buf_block_t</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>  <span class="cm">/*!&lt; in/out: buffer block of rec */</span>
</span></span><span class="line"><span class="cl">    <span class="n">dict_index_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="cm">/*!&lt; in: index */</span>
</span></span><span class="line"><span class="cl">    <span class="n">que_thr_t</span> <span class="o">*</span><span class="n">thr</span><span class="p">,</span>      <span class="cm">/*!&lt; in: query thread */</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_t</span> <span class="o">*</span><span class="n">mtr</span><span class="p">,</span>          <span class="cm">/*!&lt; in/out: mini-transaction */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="o">*</span><span class="n">inherit</span><span class="p">)</span>       <span class="cm">/*!&lt; out: set to true if the new
</span></span></span><span class="line"><span class="cl"><span class="cm">                          inserted record maybe should inherit
</span></span></span><span class="line"><span class="cl"><span class="cm">                          LOCK_GAP locks from successor record */</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTR_NO_LOCKING_FLAG</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="n">DB_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">dberr_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">DB_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">inherit_in</span> <span class="o">=</span> <span class="o">*</span><span class="n">inherit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_t</span> <span class="o">*</span><span class="n">trx</span> <span class="o">=</span> <span class="n">thr_get_trx</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">rec_t</span> <span class="o">*</span><span class="n">next_rec</span> <span class="o">=</span> <span class="n">page_rec_get_next_const</span><span class="p">(</span><span class="n">rec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">heap_no</span> <span class="o">=</span> <span class="n">page_rec_get_heap_no</span><span class="p">(</span><span class="n">next_rec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">locksys</span><span class="o">::</span><span class="n">Shard_latch_guard</span> <span class="n">guard</span><span class="p">{</span><span class="n">UT_LOCATION_HERE</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">get_page_id</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lock_rec_get_first</span><span class="p">(</span><span class="n">lock_sys</span><span class="o">-&gt;</span><span class="n">rec_hash</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">heap_no</span><span class="p">)</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 锁链上无锁，直接加隐式锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">*</span><span class="n">inherit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">inherit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">ulint</span> <span class="n">type_mode</span> <span class="o">=</span> <span class="n">LOCK_X</span> <span class="o">|</span> <span class="n">LOCK_GAP</span> <span class="o">|</span> <span class="n">LOCK_INSERT_INTENTION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 判断锁链上是否存在冲突模式的锁：如果存在其他后继记录的除 insert 目的外的 gap 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">const</span> <span class="k">auto</span> <span class="n">conflicting</span> <span class="o">=</span> <span class="n">lock_rec_other_has_conflicting</span><span class="p">(</span><span class="n">type_mode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">heap_no</span><span class="p">,</span> <span class="n">trx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">conflicting</span><span class="p">.</span><span class="n">wait_for</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RecLock</span> <span class="n">rec_lock</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">heap_no</span><span class="p">,</span> <span class="n">type_mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">trx_mutex_enter</span><span class="p">(</span><span class="n">trx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 存在冲突，加行锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">err</span> <span class="o">=</span> <span class="n">rec_lock</span><span class="p">.</span><span class="n">add_to_waitq</span><span class="p">(</span><span class="n">conflicting</span><span class="p">.</span><span class="n">wait_for</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">trx_mutex_exit</span><span class="p">(</span><span class="n">trx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DB_SUCCESS_LOCKED_REC</span><span class="p">:</span> <span class="n">err</span> <span class="o">=</span> <span class="n">DB_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DB_SUCCESS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inherit_in</span> <span class="o">||</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">is_clustered</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 二级索引更新 page 上的 max trx id 标志 */</span>
</span></span><span class="line"><span class="cl">      <span class="n">page_update_max_trx_id</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">buf_block_get_page_zip</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>更多隐式锁相关内容可以参考这篇 <a href="http://mysql.taobao.org/monthly/2020/09/06/">mysql 月报文章</a>。</p>
<p>   update 流程会先通过读接口来寻找原先需要被更新的行记录（index_read-&gt;row_search_mvcc），在读阶段就会对目标行进行加锁（lock_clust_rec_read_check_and_lock / lock_sec_rec_read_check_and_lock），这里的加锁接口和 insert 判重阶段一致，具体加锁模式还和隔离级别有关。 update 第二个阶段会真正去修改数据，也有直接 update 模式和 delete_mark + insert 模式，到 btr_cur_ 层的接口一致，因此加锁函数接口也一致。</p>
<h4 id="23-锁的释放">2.3 锁的释放<a hidden class="anchor" aria-hidden="true" href="#23-锁的释放">#</a></h4>
<p>   大多数情况下事务持有的所有锁（trx_t::lock.trx_locks）都是在事务提交时释放(trx_release_impl_and_expl_locks-&gt;lock_trx_release_locks，在 trx_commit_in_memory 阶段的开始)。有两个例外：<br>
a）AUTO-INC 锁（由参数 innodb_autoinc_lock_mode 控制）在SQL结束时直接释放（innobase_commit &ndash;&gt; lock_unlock_table_autoinc）；<br>
b）在 RC 隔离级别下执行 DML 语句时，从引擎层返回到 Server 层的记录，如果不满足 where 条件，则会立刻 unlock 掉（ha_innobase::unlock_row）。</p>
<p>   对于行锁，从 lock sys hash 中删除后还需要判断是否有正在等待的会话可以被唤醒（lock_rec_dequeue_from_page）。这里采用的是 CATS 策略将所有处于 LOCK_WAIT 状态的锁对象按trx优先权、调度权重 trx-&gt;lock.schedule_weight 排序，然后依次处理。对于每个等待状态的锁对象，如果其不再等待任何已有 granted 的锁对象（包括这次循环前面 grant 的），则清理等待事务的相关锁等待状态并唤醒线程已经挂起的等待事务；反之，则更新等待关系、继续等待。</p>
<h4 id="24-死锁检测及cats策略">2.4 死锁检测及CATS策略<a hidden class="anchor" aria-hidden="true" href="#24-死锁检测及cats策略">#</a></h4>
<p>   官方在 Bug#29882690: UNDETECTED DEADLOCK WITH GAP AND INSERT INTENTION LOCKS IS POSSIBLE 中修复部分原先无法探测的死锁，还将锁阻塞信息（wait-for图）从 lock 转移到 trx 中，并且将死锁检测从前台事务线程转移到后台监控线程。这样减轻了前台事务线程的取锁冲突时的检测代价；但是死锁会先进入事务系统，后续检测出后回滚，也就意味着死锁事务会占用一段时间的线程、内存资源、导致锁链、事务数组等的膨胀后（对应线程先进入、然后 suspend 进入睡眠等待后）才会被回滚，若是死锁概率较高的高冲突场景这可能会导致整体事务系统的性能下降。死锁处理的逻辑在 lock_wait_timeout_thread 线程中（lock_wait_update_schedule_and_check_for_deadlocks），顾名思义这个函数更新了事务权重比检查了是否存在死锁。新版死锁检测逻辑的理论基础可以参考这篇 <a href="http://mysql.taobao.org/monthly/2021/05/02/">mysql 月报文章</a>，下面主要介绍代码逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** Takes a snapshot of transactions in waiting currently in slots, updates
</span></span></span><span class="line"><span class="cl"><span class="cm">their schedule weights, searches for deadlocks among them and resolves them. */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_wait_update_schedule_and_check_for_deadlocks</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">waiting_trx_info_t</span><span class="o">&gt;</span> <span class="n">infos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">outgoing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">trx_schedule_weight_t</span><span class="o">&gt;</span> <span class="n">new_weights</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    （以下持有 lock_sys-&gt;wait_mutex）
</span></span></span><span class="line"><span class="cl"><span class="cm">    将 lock_sys 中所有 waiting 状态的 trx 及阻塞它的 blocking_trx 加入到 infos，构建 wait trx 的 snapshot；
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">table_reservations</span> <span class="o">=</span> <span class="n">lock_wait_snapshot_waiting_threads</span><span class="p">(</span><span class="n">infos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    构建 waiting for graph，实质上就是寻找某个 trx 的 blocking_trx 是否存在在 info 中，
</span></span></span><span class="line"><span class="cl"><span class="cm">    blocking_trx 也存在的话通过 outgoing 数组关联位置起来，这样就将所有依赖的 trx 串联起来，
</span></span></span><span class="line"><span class="cl"><span class="cm">    (即将这个 trx 在 info 中的 index 位置作为 outgoing index，
</span></span></span><span class="line"><span class="cl"><span class="cm">     将 blocking_trx 在 info 中的 index 位置作为 outgoing 中这个 index 对应位置的元素）
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_wait_build_wait_for_graph</span><span class="p">(</span><span class="n">infos</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    初始化事务权重值，正常等待事务初始为1，超时事务会初始为较大值；
</span></span></span><span class="line"><span class="cl"><span class="cm">    通过关联树图算出 new_weights（依赖子树元素数目）：
</span></span></span><span class="line"><span class="cl"><span class="cm">      将所有无入度的节点入栈，再遍历栈元素根据其出度确定父节点并将这个子节点的权重增加到父节点上，并减少其父节点入度计数；
</span></span></span><span class="line"><span class="cl"><span class="cm">      如果对应父节点还存在有出度，当其所有入度处理完成后（入度计数为0，其所有入度已经转化为权重值），作为无入度节点入栈同上处理；
</span></span></span><span class="line"><span class="cl"><span class="cm">      直到栈中无任何元素（不存在还有出度的元素）
</span></span></span><span class="line"><span class="cl"><span class="cm">      NOTE：如果有环存在，其上一定不存在无入度的节点，因此不会在上述步骤处理，因此入度计数不为0
</span></span></span><span class="line"><span class="cl"><span class="cm">    将除死锁环外的所有等待状态的事务权重更新（持有 lock_sys-&gt;wait_mutex）
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_wait_compute_and_publish_weights_except_cycles</span><span class="p">(</span><span class="n">infos</span><span class="p">,</span> <span class="n">table_reservations</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                      <span class="n">outgoing</span><span class="p">,</span> <span class="n">new_weights</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">innobase_deadlock_detect</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">      用 DFS 方式确定的一个死锁环，如果存在的话就选择目标并回滚事务（lock_cancel_waiting_and_release）
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock_wait_find_and_handle_deadlocks</span><span class="p">(</span><span class="n">infos</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">,</span> <span class="n">new_weights</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   CATS 策略基于后台生产的事务权重，在事务放锁选择最合适等待事务去唤醒，提升整体事务效率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_rec_grant_by_heap_no</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">in_lock</span><span class="p">,</span> <span class="n">ulint</span> <span class="n">heap_no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">hash_table</span> <span class="o">=</span> <span class="n">in_lock</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">LockDescriptorEx</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">trx_schedule_weight_t</span><span class="p">,</span> <span class="n">lock_t</span> <span class="o">*&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Scoped_heap</span> <span class="n">heap</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LockDescriptorEx</span><span class="p">))</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RecID</span> <span class="n">rec_id</span><span class="p">{</span><span class="n">in_lock</span><span class="p">,</span> <span class="n">heap_no</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Locks</span><span class="o">&lt;</span><span class="n">lock_t</span> <span class="o">*&gt;</span> <span class="n">low_priority_light</span><span class="p">{</span><span class="n">heap</span><span class="p">.</span><span class="n">get</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Locks</span><span class="o">&lt;</span><span class="n">lock_t</span> <span class="o">*&gt;</span> <span class="n">waiting</span><span class="p">{</span><span class="n">heap</span><span class="p">.</span><span class="n">get</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Locks</span><span class="o">&lt;</span><span class="n">lock_t</span> <span class="o">*&gt;</span> <span class="n">granted</span><span class="p">{</span><span class="n">heap</span><span class="p">.</span><span class="n">get</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Locks</span><span class="o">&lt;</span><span class="n">LockDescriptorEx</span><span class="o">&gt;</span> <span class="n">low_priority_heavier</span><span class="p">{</span><span class="n">heap</span><span class="p">.</span><span class="n">get</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">in_trx</span> <span class="o">=</span> <span class="n">in_lock</span><span class="o">-&gt;</span><span class="n">trx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*  对于锁链上每个 lock 划分到 granted、waiting、low_priority_light、low_priority_heavier 中：
</span></span></span><span class="line"><span class="cl"><span class="cm">    granted: 已经获取到的锁，如果等待锁被授权，也会从 waiting 转移到 granted；
</span></span></span><span class="line"><span class="cl"><span class="cm">    low_priority_light：低权重的 waiting 状态锁；
</span></span></span><span class="line"><span class="cl"><span class="cm">    low_priority_heavier：高权重的 waiting 状态锁；
</span></span></span><span class="line"><span class="cl"><span class="cm">    waiting：处于 waiting 状态的锁，最终 low_priority_light 和 low_priority_heavier 会合并入此数组；
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Lock_iter</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">rec_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">is_waiting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">granted</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="k">auto</span> <span class="n">trx</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">trx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">trx</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">==</span> <span class="n">DB_DEADLOCK</span> <span class="o">||</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">was_chosen_as_deadlock_victim</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="k">auto</span> <span class="n">blocking_trx</span> <span class="o">=</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">blocking_trx</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">blocking_trx</span> <span class="o">!=</span> <span class="n">in_trx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">trx_is_high_priority</span><span class="p">(</span><span class="n">trx</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">waiting</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 这个等待的事务还有等待它的事务，认为是高权重 */</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="k">auto</span> <span class="n">schedule_weight</span> <span class="o">=</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">schedule_weight</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">schedule_weight</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">low_priority_light</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">low_priority_heavier</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LockDescriptorEx</span><span class="p">{</span><span class="n">schedule_weight</span><span class="p">,</span> <span class="n">lock</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="n">hash_table</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">waiting</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">low_priority_light</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">low_priority_heavier</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 按权重进行排序，高权重优先 grant */</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">low_priority_heavier</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">low_priority_heavier</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">[](</span><span class="k">const</span> <span class="n">LockDescriptorEx</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">LockDescriptorEx</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">);});</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">descriptor</span> <span class="p">:</span> <span class="n">low_priority_heavier</span><span class="p">)</span> <span class="p">{</span><span class="n">waiting</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">second</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="n">waiting</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">waiting</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">low_priority_light</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">low_priority_light</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">new_granted_index</span> <span class="o">=</span> <span class="n">granted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">granted</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">granted</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">waiting</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="nl">wait_lock</span> <span class="p">:</span> <span class="n">waiting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 已授权锁是否会阻塞当前锁 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">lock_t</span> <span class="o">*</span><span class="n">blocking_lock</span> <span class="o">=</span> <span class="n">lock_rec_has_to_wait_for_granted</span><span class="p">(</span><span class="n">wait_lock</span><span class="p">,</span> <span class="n">granted</span><span class="p">,</span> <span class="n">new_granted_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">blocking_lock</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock_grant</span><span class="p">(</span><span class="n">wait_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock_rec_move_granted_to_front</span><span class="p">(</span><span class="n">wait_lock</span><span class="p">,</span> <span class="n">rec_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">granted</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">wait_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* 等待的锁等待原因可能改变，更新 wait_for 图 */</span>
</span></span><span class="line"><span class="cl">      <span class="n">lock_update_wait_for_edge</span><span class="p">(</span><span class="n">wait_lock</span><span class="p">,</span> <span class="n">blocking_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/mysql/">MySQL</a></li>
      <li><a href="https://mzyee.github.io/tags/lock/">Lock</a></li>
      <li><a href="https://mzyee.github.io/tags/transaction/">Transaction</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://mzyee.github.io/posts/mysql/meta/">
    <span class="title">下一页 »</span>
    <br>
    <span>MySQL 如何准备开启一个表</span>
  </a>
</nav>

  </footer>
<div>
  <div class="pagination__title">
    <span class="pagination__title-h" style="font-size: 20px;">💬 评论</span>
    <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.staticfile.org/twikoo/1.6.25/twikoo.all.min.js"></script>
  <script>
    twikoo.init({
      envId: "https://mzyeee.netlify.app/.netlify/functions/twikoo",  
      el: "#tcomment",
      lang: 'zh-CN',
      region: 'ap-hongkong',
      path: window.TWIKOO_MAGIC_PATH || window.location.pathname,
    });
  </script>
</div>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
