<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>InnoDB Purge System 代码学习 | MZY&#39;s Blog</title>
<meta name="keywords" content="MySQL, Undo, MVCC">
<meta name="description" content="InnoDB Purge System 相关代码学习">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/mysql/purge/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.78ed8947c1508d00bdf7a3061370dcaebcd4ba680f4567ec440d26a4043b4e64.css" integrity="sha256-eO2JR8FQjQC996MGE3DcrrzUumgPRWfsRA0mpAQ7TmQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="InnoDB Purge System 代码学习" />
<meta property="og:description" content="InnoDB Purge System 相关代码学习" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/mysql/purge/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-10-23T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="InnoDB Purge System 代码学习"/>
<meta name="twitter:description" content="InnoDB Purge System 相关代码学习"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL",
      "item": "https://mzyee.github.io/posts/mysql/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "InnoDB Purge System 代码学习",
      "item": "https://mzyee.github.io/posts/mysql/purge/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "InnoDB Purge System 代码学习",
  "name": "InnoDB Purge System 代码学习",
  "description": "InnoDB Purge System 相关代码学习",
  "keywords": [
    "MySQL", "Undo", "MVCC"
  ],
  "articleBody": "1. 前言 本文讨论 InnoDB 的 Purge 子系统的代码实现，建议先阅读 Undo 系统的介绍。\n2. Purge 系统 InnoDB 控制 purge 操作的结构体是 trx_purge_t，其中主要维护了需要被 purge 的回滚段、purge view、purge 状态位置等。全局 trx_purge_t 结构会在 innodb 启动时的trx_sys_init_at_db_start函数通过扫描所有rollback segment 来初始化设定，其内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 struct trx_purge_t { sess_t *sess; // purge的系统session trx_t *trx; // purge的系统trx，不在 trx list rw_lock_t latch; // purge view，state的保护锁 os_event_t event; // state的信号 ulint n_stop; // 停止追踪器 volatile bool running; // 是否在运行 volatile purge_state_t state; // Coordinator状态：INIT、RUN、STOP、EXIT、DISABLED que_t *query; // 运行purge用的query graph ReadView view; // purge view，大于或出现在这个view的undo不会被purge bool view_active; // purge view是否有效 volatile ulint n_submitted; // 提交的purge任务数目 std::atomic\u003culint\u003e n_completed; // 完成的purge任务数目 /* 追踪purge的位置，用于history list truncation */ purge_iter_t iter; // 已经read和parsed的UNDO log位置，一定比limit更新 purge_iter_t limit; // 已经purge（或已经分配马上要purge）的UNDO log位置 bool next_stored; // 标记要purge的下一个undo是否存在下面这些变量中 trx_rseg_t *rseg; // 下一个purge的回滚段 page_no_t page_no; // 下一个purge的undo的page no ulint offset; // 下一个purge的undo的page in-page-offset page_no_t hdr_page_no; // 下一个purge的undo的header page ulint hdr_offset; // // 下一个purge的undo的header page in-page-offset TrxUndoRsegsIterator *rseg_iter; // 用于获取下一个purge的回滚段 purge_pq_t *purge_queue; // 按trx_no排序的要被purge的（update）回滚段，内存 PQMutex pq_mutex; undo::Truncate undo_trunc; // 标记要truncate的undospace mem_heap_t *heap; std::vector\u003ctrx_rseg_t *\u003e rsegs_queue; // 存储所有的回滚段 }; 3. Purge 主流程代码 在ddl恢复完成（innobase_post_recover），保证 tablespaces 相关元信息状态一致后，系统会启动 srv_purge_coordinator_thread 和 srv_worker_thread 来进行 undo purge。srv_purge_coordinator_thread 是主要控制 purge 流程的任务线程，在运行期间循环调用 srv_do_purge 去尽可能 purge 所有 undo。在srv_do_purge中每次 purge 一批 undo 会根据系统状态自适应调整 purge 系统所使用的线程数目。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void srv_purge_coordinator_thread() { // 初始化环境，something... do { // 常态循环 /* 如果上一次purge没有清理东西，则suspend暂停等待信号，避免空转； 另外，外部操作像 FLUSH TABLES FOR EXPORT 会静默tablespace等的也会暂停purge */ if (srv_shutdown_state == SRV_SHUTDOWN_NONE \u0026\u0026 (purge_sys-\u003estate == PURGE_STATE_STOP || n_total_purged == 0)) { srv_purge_coordinator_suspend(slot, rseg_history_len); } if (srv_purge_should_exit(n_total_purged)) break; n_total_purged = 0; rseg_history_len = srv_do_purge(\u0026n_total_purged); // 自己做purge } while (!srv_purge_should_exit(n_total_purged)); // 退出清理undo /* 如果不是fast shutdown，确保所有记录被purge，退出阶段也可能有加入undo记录，清理所有后台线程参数的undo */ ulint n_pages_purged = ULINT_MAX; while (srv_fast_shutdown == 0 \u0026\u0026 n_pages_purged \u003e 0) { n_pages_purged = trx_purge(1, srv_purge_batch_size, false); } n_pages_purged = trx_purge(1, ut_min(srv_purge_batch_size, 20), true); ut_a(n_pages_purged == 0 || srv_fast_shutdown != 0); // 清理环境，something... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static ulint srv_do_purge(ulint *n_total_purged) { // 初始化环境，something... do { // 常态循环尽可能purge // S1. 通过当前系统和history状态，调整purge threads数目：... // S2. 判断是否需要进行undo truncate：... // S3. 调用trx_purge实际做purge n_pages_purged = trx_purge(n_use_threads, srv_purge_batch_size, do_truncate); *n_total_purged += n_pages_purged; // S4. 判断是否有需要truncate的undo space以再次进入：... } while (purge_sys-\u003estate == PURGE_STATE_RUN \u0026\u0026 (n_pages_purged \u003e 0 || need_explicit_truncate) \u0026\u0026 !srv_purge_should_exit(n_pages_purged)); return rseg_history_len; // 上一批purge前的history长度 } Purge coordinator 的实际 purge 任务是在 trx_purge 中进行分配和进行的， coordinator 会将 undo record 分配给 srv_sys-\u003etasks 中对应数目的 query thread，Purge worker 直接匹配系统环境的 query thread 拿 query thread node（purge_node_t类型）进行执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 ulint trx_purge(ulint n_purge_threads, ulint batch_size, bool truncate) { // S0. 初始化，something... /****************************************************** S1. 获取（clone）最老 read view 用于为 MVCC 限制 purge 的位置 *******************************************************/ rw_lock_x_lock(\u0026purge_sys-\u003elatch, UT_LOCATION_HERE); purge_sys-\u003eview_active = false; trx_sys-\u003emvcc-\u003eclone_oldest_view(\u0026purge_sys-\u003eview); purge_sys-\u003eview_active = true; rw_lock_x_unlock(\u0026purge_sys-\u003elatch); /****************************************************** S2. 给 purge_sys 每个 query thread 的执行节点（purge_node_t）分配 undo recs *******************************************************/ /* S2.0. 在 trx_commit 时候将 update undo 写入 purge_queue，（insert undo 直接更新成 cache 或者 free）； S2.1. purge_sys 维护了 next undo rec 的位置（purge_sys-\u003eiter），这里从这一位置开始获取batch_size大小的 undo rec S2.2. 将获取的 undo rec 分配给不同的work thread，这里官方先按table ID进行分配，再进行平衡尽可能保证各 worker 的 undo 数目均匀 （查看提交 Bug #32089028 CONCURRENTLY UPDATING MANY JSON DOCUMENTS STEADILY INCREASES IBD FILE SIZE） S2.3. 将 undo rec 真正分配挂到 query thread 的执行节点 purge_node_t 上 */ n_pages_handled = trx_purge_attach_undo_recs(n_purge_threads, batch_size); /****************************************************** S3. 启动并进行 purge 任务 *******************************************************/ // S3.1. 启动所有query thread if (n_purge_threads \u003e 1) { for (ulint i = 0; i \u003c n_purge_threads - 1; ++i) { thr = que_fork_scheduler_round_robin(purge_sys-\u003equery, thr); // 向后台 srv_sys-\u003etasks 提交任务，以供 purger worker 执行 srv_que_task_enqueue_low(thr); } purge_sys-\u003en_submitted += n_purge_threads - 1; thr = que_fork_scheduler_round_robin(purge_sys-\u003equery, thr); } else { thr = que_fork_scheduler_round_robin(purge_sys-\u003equery, nullptr); } ++purge_sys-\u003en_submitted; // S3.2. 执行purge任务，并等待所有worker完成 que_run_threads(thr); purge_sys-\u003en_completed.fetch_add(1); if (n_purge_threads \u003e 1) trx_purge_wait_for_workers_to_complete(); /****************************************************** S4. 将所有 blob's first page 延迟到末尾统一释放，避免访问 freed page *******************************************************/ for (thr = UT_LIST_GET_FIRST(purge_sys-\u003equery-\u003ethrs); thr != nullptr; thr = UT_LIST_GET_NEXT(thrs, thr)) { purge_node_t *node = static_cast\u003cpurge_node_t *\u003e(thr-\u003echild); node-\u003efree_lob_pages(); } /****************************************************** S5. 进行 undospace truncate *******************************************************/ if (truncate || srv_upgrade_old_undo_found) { trx_purge_truncate(); } return (n_pages_handled); } 4. Purge 物理操作 在row_purge中会对在对应 query thread 的 run_node（purge_node_t）中取的 undo record 记录进行 purge，直到 purge 完所有分配的 undo record：\n首先解析 undo record 获取 trxid、tableid 等操作信息，通过 tableid 开启 innodb 表并获取 Shared MDL 锁，然后构建 row reference 等信息。这里的逻辑类似 rollback 操作的的第一步解析； 然后对 delete mark 类型的操作 purge 掉所有二级索引和主键上不再需要的 index record（包括extern field），这里也是先根据 row reference 索引 BTree 到对应的 cursor 上，删除走的是 btr_cur 的 delete 接口 btr_cur_optimistic_delete 和 btr_cur_pessimistic_delete； 5. Purge truncate 前一个阶段 purge 物理操作只是将索引上的数据删除，但是不会处理 undospace 内的空间。虽然 undo log 可以被 purge，但是类似 ibd 文件（不主动optimize）一旦文件增大那么就无法缩小。Innodb 在一个 undo 表空间没有事务使用时，允许将其 truncate 来回收 undo 表空间。回收动作在 coordinator 一批 purge 任务完成后触发，接口为trx_purge_truncate，其内部主要分为 purge rollback segment 和 truncate space 两个部分。\npurge rollback segment（trx_purge_truncate_history）会从所有表空间的所有回滚段回收无用的 undo 数据并清理 history list； truncate space（trx_purge_truncate_undo_spaces）会检索是否存在满足truncate要求的 undospace（1. 手动设置为 inactive 或大小超过限制；2. 空间中 undo 记录被 purge 完全且没有被任何事务使用），并进行物理文件 truncate 操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** 清理某个 rollback segment */ static void trx_purge_truncate_rseg_history( trx_rseg_t *rseg, /*!\u003c in: rollback segment */ const purge_iter_t *limit) /*!\u003c in: truncate offset */ { // 变量初始化，something... // 从当前 rollback segment 的 history list 上面获取最后位置的 undo log header rseg-\u003elatch(); rseg_hdr = trx_rsegf_get(rseg-\u003espace_id, rseg-\u003epage_no, rseg-\u003epage_size, \u0026mtr); hdr_addr = trx_purge_get_log_from_hist(flst_get_last(rseg_hdr + TRX_RSEG_HISTORY, \u0026mtr)); loop: if (hdr_addr.page == FIL_NULL) { // history 不剩下需要处理的 undo rseg-\u003eunlatch(); mtr_commit(\u0026mtr); return; } undo_page = trx_undo_page_get(page_id_t(rseg-\u003espace_id, hdr_addr.page), rseg-\u003epage_size, \u0026mtr); log_hdr = undo_page + hdr_addr.boffset; seg_hdr = undo_page + TRX_UNDO_SEG_HDR; undo_trx_no = mach_read_from_8(log_hdr + TRX_UNDO_TRX_NO); if (undo_trx_no \u003e= limit-\u003etrx_no) { // 当前要处理的 undo 已经到达、超过 purge limit if (undo_trx_no == limit-\u003etrx_no \u0026\u0026 rseg-\u003espace_id == limit-\u003eundo_rseg_space) { // 将所有小于 limit 的 undo normal page free，header page empty trx_undo_truncate_start(rseg, hdr_addr.page, hdr_addr.boffset, limit-\u003eundo_no); } rseg-\u003eunlatch(); mtr_commit(\u0026mtr); return; } prev_hdr_addr = trx_purge_get_log_from_hist(flst_get_prev_addr(log_hdr + TRX_UNDO_HISTORY_NODE, \u0026mtr)); if ((mach_read_from_2(seg_hdr + TRX_UNDO_STATE) == TRX_UNDO_TO_PURGE) \u0026\u0026 (mach_read_from_2(log_hdr + TRX_UNDO_NEXT_LOG) == 0)) { // 无log剩余，回收整个 undo segment rseg-\u003eunlatch(); mtr_commit(\u0026mtr); trx_purge_free_segment(rseg, hdr_addr, is_temp); // 内部有trx_purge_remove_log_hdr删除history list节点 } else { // 在history list上删除当前 log header（这里相当于我那次一条history的purge） trx_purge_remove_log_hdr(rseg_hdr, log_hdr, \u0026mtr); rseg-\u003eunlatch(); mtr_commit(\u0026mtr); } // 转移到 history list 上的下一条log mtr_start(\u0026mtr); if (is_temp) { mtr.set_log_mode(MTR_LOG_NO_REDO); } rseg-\u003elatch(); rseg_hdr = trx_rsegf_get(rseg-\u003espace_id, rseg-\u003epage_no, rseg-\u003epage_size, \u0026mtr); hdr_addr = prev_hdr_addr; goto loop; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // 进行物理文件 truncate static bool trx_purge_truncate_marked_undo() { // S0. 变量初始化，something... /****************************************************** S1. 获取 MDL 锁 *******************************************************/ MDL_ticket *mdl_ticket; bool dd_result = dd_tablespace_get_mdl(space_name.c_str(), \u0026mdl_ticket, false); // something... /****************************************************** S2. 开始 truncate 操作，切换 undospace *******************************************************/ mutex_enter(\u0026undo::ddl_mutex); if (!trx_purge_truncate_marked_undo_low(space_num, space_name)) { mutex_exit(\u0026undo::ddl_mutex); dd_release_mdl(mdl_ticket); MONITOR_INC_TIME(MONITOR_UNDO_TRUNCATE_MICROSECOND, counter_time_truncate); return (false); } /****************************************************** S3. 删除 undo log file，标志 undo truncate 完成 *******************************************************/ undo::spaces-\u003ex_lock(); undo::done_logging(space_num); undo::spaces-\u003ex_unlock(); // S4. 清理环境，something... return (true); } static bool trx_purge_truncate_marked_undo_low(space_id_t space_num, std::string space_name) { /****************************************************** S2.1. 获取环境 *******************************************************/ // someting... /****************************************************** S2.2. 创建 undo 文件，标志 undo truncate 开始 *******************************************************/ dberr_t err = undo::start_logging(marked_space); // someting... /****************************************************** S2.3. 过滤特殊条件，someting... *******************************************************/ /****************************************************** S2.4. 实际 undo space 文件裁剪轮转 *******************************************************/ /* 计算新 undo space id 和 undo space no； 删除+新建 file tablespace（fil_delete_tablespace + fil_ibd_create）； 重新初始化新 tablespace 文件，构建 undo 文件内容； 重新设置相应 undo space 回滚段内存结构体（Rsegs *m_rsegs） */ bool success = trx_undo_truncate_tablespace(marked_space); // someting... /****************************************************** S2.5. 设定此 undo 空间后面的可用状态 *******************************************************/ space_id_t new_space_id = marked_space-\u003eid(); dd_space_states next_state; undo::spaces-\u003es_lock(); Rsegs *marked_rsegs = marked_space-\u003ersegs(); marked_rsegs-\u003ex_lock(); if (marked_rsegs-\u003eis_inactive_explicit()) { // 由外部手动 inactive next_state = DD_SPACE_STATE_EMPTY; marked_rsegs-\u003eset_empty(); } else { // 由后台 purge 选择，可被再使用 next_state = DD_SPACE_STATE_ACTIVE; marked_rsegs-\u003eset_active(); } /****************************************************** S2.6. 在 DD 中更新 space ID 和 state 信息 *******************************************************/ if (DD_FAILURE == dd_tablespace_set_id_and_state(space_name.c_str(), new_space_id, next_state)) return (false); return (true); } 版权声明：如需转载或引用，请附加本文链接并注明来源。 ",
  "wordCount" : "1372",
  "inLanguage": "zh",
  "datePublished": "2023-10-23T00:00:00Z",
  "dateModified": "2023-10-23T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/mysql/purge/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title=" MZY&#39;s Blog (Alt + H)">
                <img src="https://mzyee.github.io/img/eye.jpg" alt="" aria-label="logo"
                    height="38"> MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/mysql/">MySQL</a></div>
    <h1 class="post-title">
      InnoDB Purge System 代码学习
    </h1>
    <div class="post-meta"><span title='2023-10-23 00:00:00 +0000 UTC'>十月 23, 2023</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;Miao Zheyu
      &nbsp;|&nbsp;📖 &nbsp;
      <ul class="post-tags-meta">
        <a href="https://mzyee.github.io/tags/mysql/">MySQL</a>
        <a href="https://mzyee.github.io/tags/undo/">&nbsp;Undo</a>
        <a href="https://mzyee.github.io/tags/mvcc/">&nbsp;MVCC</a>
      </ul>&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e5%89%8d%e8%a8%80" aria-label="1. 前言">1. 前言</a></li>
                    <li>
                        <a href="#2-purge-%e7%b3%bb%e7%bb%9f" aria-label="2. Purge 系统">2. Purge 系统</a></li>
                    <li>
                        <a href="#3-purge-%e4%b8%bb%e6%b5%81%e7%a8%8b%e4%bb%a3%e7%a0%81" aria-label="3. Purge 主流程代码">3. Purge 主流程代码</a></li>
                    <li>
                        <a href="#4-purge-%e7%89%a9%e7%90%86%e6%93%8d%e4%bd%9c" aria-label="4. Purge 物理操作">4. Purge 物理操作</a></li>
                    <li>
                        <a href="#5-purge-truncate" aria-label="5. Purge truncate">5. Purge truncate</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><h3 id="1-前言">1. 前言<a hidden class="anchor" aria-hidden="true" href="#1-前言">#</a></h3>
<p>   本文讨论 InnoDB 的 Purge 子系统的代码实现，建议先阅读 <a href="https://mzyee.github.io/posts/mysql/undo">Undo 系统</a>的介绍。</p>
<!-- Purge系统 -->
<h3 id="2-purge-系统">2. Purge 系统<a hidden class="anchor" aria-hidden="true" href="#2-purge-系统">#</a></h3>
<p>   InnoDB 控制 purge 操作的结构体是 trx_purge_t，其中主要维护了需要被 purge 的回滚段、purge view、purge 状态位置等。全局 trx_purge_t 结构会在 innodb 启动时的<code>trx_sys_init_at_db_start</code>函数通过扫描所有rollback segment 来初始化设定，其内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">trx_purge_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sess_t</span> <span class="o">*</span><span class="n">sess</span><span class="p">;</span> <span class="c1">// purge的系统session
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">trx_t</span> <span class="o">*</span><span class="n">trx</span><span class="p">;</span> <span class="c1">// purge的系统trx，不在 trx list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">rw_lock_t</span> <span class="n">latch</span><span class="p">;</span> <span class="c1">// purge view，state的保护锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">os_event_t</span> <span class="n">event</span><span class="p">;</span> <span class="c1">// state的信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">n_stop</span><span class="p">;</span> <span class="c1">// 停止追踪器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">running</span><span class="p">;</span> <span class="c1">// 是否在运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">volatile</span> <span class="n">purge_state_t</span> <span class="n">state</span><span class="p">;</span> <span class="c1">// Coordinator状态：INIT、RUN、STOP、EXIT、DISABLED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">que_t</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span> <span class="c1">// 运行purge用的query graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">ReadView</span> <span class="n">view</span><span class="p">;</span> <span class="c1">// purge view，大于或出现在这个view的undo不会被purge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">view_active</span><span class="p">;</span> <span class="c1">// purge view是否有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="n">ulint</span> <span class="n">n_submitted</span><span class="p">;</span> <span class="c1">// 提交的purge任务数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">ulint</span><span class="o">&gt;</span> <span class="n">n_completed</span><span class="p">;</span> <span class="c1">// 完成的purge任务数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 追踪purge的位置，用于history list truncation */</span>
</span></span><span class="line"><span class="cl">  <span class="n">purge_iter_t</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">// 已经read和parsed的UNDO log位置，一定比limit更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">purge_iter_t</span> <span class="n">limit</span><span class="p">;</span> <span class="c1">// 已经purge（或已经分配马上要purge）的UNDO log位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">next_stored</span><span class="p">;</span> <span class="c1">// 标记要purge的下一个undo是否存在下面这些变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">trx_rseg_t</span> <span class="o">*</span><span class="n">rseg</span><span class="p">;</span> <span class="c1">// 下一个purge的回滚段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">page_no_t</span> <span class="n">page_no</span><span class="p">;</span> <span class="c1">// 下一个purge的undo的page no
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ulint</span> <span class="n">offset</span><span class="p">;</span> <span class="c1">// 下一个purge的undo的page in-page-offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">page_no_t</span> <span class="n">hdr_page_no</span><span class="p">;</span> <span class="c1">// 下一个purge的undo的header page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ulint</span> <span class="n">hdr_offset</span><span class="p">;</span> <span class="c1">// // 下一个purge的undo的header page in-page-offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">TrxUndoRsegsIterator</span> <span class="o">*</span><span class="n">rseg_iter</span><span class="p">;</span> <span class="c1">// 用于获取下一个purge的回滚段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">purge_pq_t</span> <span class="o">*</span><span class="n">purge_queue</span><span class="p">;</span> <span class="c1">// 按trx_no排序的要被purge的（update）回滚段，内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PQMutex</span> <span class="n">pq_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">Truncate</span> <span class="n">undo_trunc</span><span class="p">;</span> <span class="c1">// 标记要truncate的undospace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">mem_heap_t</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">trx_rseg_t</span> <span class="o">*&gt;</span> <span class="n">rsegs_queue</span><span class="p">;</span> <span class="c1">// 存储所有的回滚段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-purge-主流程代码">3. Purge 主流程代码<a hidden class="anchor" aria-hidden="true" href="#3-purge-主流程代码">#</a></h3>
<p>   在ddl恢复完成（<code>innobase_post_recover</code>），保证 tablespaces 相关元信息状态一致后，系统会启动 srv_purge_coordinator_thread 和 srv_worker_thread 来进行 undo purge。srv_purge_coordinator_thread 是主要控制 purge 流程的任务线程，在运行期间循环调用 <code>srv_do_purge</code> 去尽可能 purge 所有 undo。在<code>srv_do_purge</code>中每次 purge 一批 undo 会根据系统状态自适应调整 purge 系统所使用的线程数目。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">srv_purge_coordinator_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化环境，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span> <span class="c1">// 常态循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">      如果上一次purge没有清理东西，则suspend暂停等待信号，避免空转；
</span></span></span><span class="line"><span class="cl"><span class="cm">      另外，外部操作像 FLUSH TABLES FOR EXPORT 会静默tablespace等的也会暂停purge
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">srv_shutdown_state</span> <span class="o">==</span> <span class="n">SRV_SHUTDOWN_NONE</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PURGE_STATE_STOP</span> <span class="o">||</span> <span class="n">n_total_purged</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">srv_purge_coordinator_suspend</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">rseg_history_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">srv_purge_should_exit</span><span class="p">(</span><span class="n">n_total_purged</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">n_total_purged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rseg_history_len</span> <span class="o">=</span> <span class="n">srv_do_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_total_purged</span><span class="p">);</span> <span class="c1">// 自己做purge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">srv_purge_should_exit</span><span class="p">(</span><span class="n">n_total_purged</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 退出清理undo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* 如果不是fast shutdown，确保所有记录被purge，退出阶段也可能有加入undo记录，清理所有后台线程参数的undo */</span>
</span></span><span class="line"><span class="cl">  <span class="n">ulint</span> <span class="n">n_pages_purged</span> <span class="o">=</span> <span class="n">ULINT_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">srv_fast_shutdown</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n_pages_purged</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_pages_purged</span> <span class="o">=</span> <span class="n">trx_purge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">srv_purge_batch_size</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">n_pages_purged</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">trx_purge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ut_min</span><span class="p">(</span><span class="n">srv_purge_batch_size</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut_a</span><span class="p">(</span><span class="n">n_pages_purged</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">srv_fast_shutdown</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 清理环境，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">ulint</span> <span class="nf">srv_do_purge</span><span class="p">(</span><span class="n">ulint</span> <span class="o">*</span><span class="n">n_total_purged</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化环境，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span> <span class="c1">// 常态循环尽可能purge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// S1. 通过当前系统和history状态，调整purge threads数目：...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// S2. 判断是否需要进行undo truncate：...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// S3. 调用trx_purge实际做purge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">n_pages_purged</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">trx_purge</span><span class="p">(</span><span class="n">n_use_threads</span><span class="p">,</span> <span class="n">srv_purge_batch_size</span><span class="p">,</span> <span class="n">do_truncate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">n_total_purged</span> <span class="o">+=</span> <span class="n">n_pages_purged</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// S4. 判断是否有需要truncate的undo space以再次进入：...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PURGE_STATE_RUN</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="n">n_pages_purged</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_explicit_truncate</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">           <span class="o">!</span><span class="n">srv_purge_should_exit</span><span class="p">(</span><span class="n">n_pages_purged</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rseg_history_len</span><span class="p">;</span> <span class="c1">// 上一批purge前的history长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   Purge coordinator 的实际 purge 任务是在 <code>trx_purge</code> 中进行分配和进行的， coordinator 会将 undo record 分配给 srv_sys-&gt;tasks 中对应数目的 query thread，Purge worker 直接匹配系统环境的 query thread 拿 query thread node（purge_node_t类型）进行执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ulint</span> <span class="nf">trx_purge</span><span class="p">(</span><span class="n">ulint</span> <span class="n">n_purge_threads</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">ulint</span> <span class="n">batch_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">bool</span> <span class="n">truncate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// S0. 初始化，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S1. 获取（clone）最老 read view 用于为 MVCC 限制 purge 的位置
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">rw_lock_x_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">,</span> <span class="n">UT_LOCATION_HERE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">view_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_sys</span><span class="o">-&gt;</span><span class="n">mvcc</span><span class="o">-&gt;</span><span class="n">clone_oldest_view</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">view_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rw_lock_x_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2. 给 purge_sys 每个 query thread 的执行节点（purge_node_t）分配 undo recs
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.0. 在 trx_commit 时候将 update undo 写入 purge_queue，（insert undo 直接更新成 cache 或者 free）；
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.1. purge_sys 维护了 next undo rec 的位置（purge_sys-&gt;iter），这里从这一位置开始获取batch_size大小的 undo rec
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.2. 将获取的 undo rec 分配给不同的work thread，这里官方先按table ID进行分配，再进行平衡尽可能保证各 worker 的 undo 数目均匀
</span></span></span><span class="line"><span class="cl"><span class="cm">      （查看提交 Bug #32089028 CONCURRENTLY UPDATING MANY JSON DOCUMENTS STEADILY INCREASES IBD FILE SIZE）
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.3. 将 undo rec 真正分配挂到 query thread 的执行节点 purge_node_t 上
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">n_pages_handled</span> <span class="o">=</span> <span class="n">trx_purge_attach_undo_recs</span><span class="p">(</span><span class="n">n_purge_threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S3. 启动并进行 purge 任务
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// S3.1. 启动所有query thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">n_purge_threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">ulint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_purge_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">thr</span> <span class="o">=</span> <span class="n">que_fork_scheduler_round_robin</span><span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">,</span> <span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 向后台 srv_sys-&gt;tasks 提交任务，以供 purger worker 执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">srv_que_task_enqueue_low</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">n_submitted</span> <span class="o">+=</span> <span class="n">n_purge_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">thr</span> <span class="o">=</span> <span class="n">que_fork_scheduler_round_robin</span><span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">,</span> <span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">thr</span> <span class="o">=</span> <span class="n">que_fork_scheduler_round_robin</span><span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">n_submitted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// S3.2. 执行purge任务，并等待所有worker完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">que_run_threads</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">n_completed</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n_purge_threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">trx_purge_wait_for_workers_to_complete</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S4. 将所有 blob&#39;s first page 延迟到末尾统一释放，避免访问 freed page
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">thr</span> <span class="o">=</span> <span class="n">UT_LIST_GET_FIRST</span><span class="p">(</span><span class="n">purge_sys</span><span class="o">-&gt;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">thrs</span><span class="p">);</span> <span class="n">thr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">thr</span> <span class="o">=</span> <span class="n">UT_LIST_GET_NEXT</span><span class="p">(</span><span class="n">thrs</span><span class="p">,</span> <span class="n">thr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">purge_node_t</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">purge_node_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">thr</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="o">-&gt;</span><span class="n">free_lob_pages</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S5. 进行 undospace truncate
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">truncate</span> <span class="o">||</span> <span class="n">srv_upgrade_old_undo_found</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_purge_truncate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">n_pages_handled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-purge-物理操作">4. Purge 物理操作<a hidden class="anchor" aria-hidden="true" href="#4-purge-物理操作">#</a></h3>
<p>   在<code>row_purge</code>中会对在对应 query thread 的 run_node（purge_node_t）中取的 undo record 记录进行 purge，直到 purge 完所有分配的 undo record：</p>
<ul>
<li>首先解析 undo record 获取 trxid、tableid 等操作信息，通过 tableid 开启 innodb 表并获取 Shared MDL 锁，然后构建 row reference 等信息。这里的逻辑类似 rollback 操作的的第一步解析；</li>
<li>然后对 delete mark 类型的操作 purge 掉所有二级索引和主键上不再需要的 index record（包括extern field），这里也是先根据 row reference 索引 BTree 到对应的 cursor 上，删除走的是 btr_cur 的 delete 接口 <code>btr_cur_optimistic_delete</code> 和 <code>btr_cur_pessimistic_delete</code>；</li>
</ul>
<h3 id="5-purge-truncate">5. Purge truncate<a hidden class="anchor" aria-hidden="true" href="#5-purge-truncate">#</a></h3>
<p>   前一个阶段 purge 物理操作只是将索引上的数据删除，但是不会处理 undospace 内的空间。虽然 undo log 可以被 purge，但是类似 ibd 文件（不主动optimize）一旦文件增大那么就无法缩小。Innodb 在一个 undo 表空间没有事务使用时，允许将其 truncate 来回收 undo 表空间。回收动作在 coordinator 一批 purge 任务完成后触发，接口为<code>trx_purge_truncate</code>，其内部主要分为 purge rollback segment 和 truncate space 两个部分。</p>
<ul>
<li>purge rollback segment（<code>trx_purge_truncate_history</code>）会从所有表空间的所有回滚段回收无用的 undo 数据并清理 history list；</li>
<li>truncate space（<code>trx_purge_truncate_undo_spaces</code>）会检索是否存在满足truncate要求的 undospace（1. 手动设置为 inactive 或大小超过限制；2. 空间中 undo 记录被 purge 完全且没有被任何事务使用），并进行物理文件 truncate 操作。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** 清理某个 rollback segment */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">trx_purge_truncate_rseg_history</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_rseg_t</span> <span class="o">*</span><span class="n">rseg</span><span class="p">,</span>          <span class="cm">/*!&lt; in: rollback segment */</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">purge_iter_t</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span> <span class="cm">/*!&lt; in: truncate offset */</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 变量初始化，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从当前 rollback segment 的 history list 上面获取最后位置的 undo log header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">rseg_hdr</span> <span class="o">=</span> <span class="n">trx_rsegf_get</span><span class="p">(</span><span class="n">rseg</span><span class="o">-&gt;</span><span class="n">space_id</span><span class="p">,</span> <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">page_no</span><span class="p">,</span> <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">hdr_addr</span> <span class="o">=</span> <span class="n">trx_purge_get_log_from_hist</span><span class="p">(</span><span class="n">flst_get_last</span><span class="p">(</span><span class="n">rseg_hdr</span> <span class="o">+</span> <span class="n">TRX_RSEG_HISTORY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">loop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">hdr_addr</span><span class="p">.</span><span class="n">page</span> <span class="o">==</span> <span class="n">FIL_NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// history 不剩下需要处理的 undo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">unlatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">undo_page</span> <span class="o">=</span> <span class="n">trx_undo_page_get</span><span class="p">(</span><span class="n">page_id_t</span><span class="p">(</span><span class="n">rseg</span><span class="o">-&gt;</span><span class="n">space_id</span><span class="p">,</span> <span class="n">hdr_addr</span><span class="p">.</span><span class="n">page</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">log_hdr</span> <span class="o">=</span> <span class="n">undo_page</span> <span class="o">+</span> <span class="n">hdr_addr</span><span class="p">.</span><span class="n">boffset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">seg_hdr</span> <span class="o">=</span> <span class="n">undo_page</span> <span class="o">+</span> <span class="n">TRX_UNDO_SEG_HDR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">undo_trx_no</span> <span class="o">=</span> <span class="n">mach_read_from_8</span><span class="p">(</span><span class="n">log_hdr</span> <span class="o">+</span> <span class="n">TRX_UNDO_TRX_NO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">undo_trx_no</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="o">-&gt;</span><span class="n">trx_no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前要处理的 undo 已经到达、超过 purge limit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">undo_trx_no</span> <span class="o">==</span> <span class="n">limit</span><span class="o">-&gt;</span><span class="n">trx_no</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">space_id</span> <span class="o">==</span> <span class="n">limit</span><span class="o">-&gt;</span><span class="n">undo_rseg_space</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 将所有小于 limit 的 undo normal page free，header page empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">trx_undo_truncate_start</span><span class="p">(</span><span class="n">rseg</span><span class="p">,</span> <span class="n">hdr_addr</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">hdr_addr</span><span class="p">.</span><span class="n">boffset</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">limit</span><span class="o">-&gt;</span><span class="n">undo_no</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">unlatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">prev_hdr_addr</span> <span class="o">=</span> <span class="n">trx_purge_get_log_from_hist</span><span class="p">(</span><span class="n">flst_get_prev_addr</span><span class="p">(</span><span class="n">log_hdr</span> <span class="o">+</span> <span class="n">TRX_UNDO_HISTORY_NODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">mach_read_from_2</span><span class="p">(</span><span class="n">seg_hdr</span> <span class="o">+</span> <span class="n">TRX_UNDO_STATE</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRX_UNDO_TO_PURGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">mach_read_from_2</span><span class="p">(</span><span class="n">log_hdr</span> <span class="o">+</span> <span class="n">TRX_UNDO_NEXT_LOG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 无log剩余，回收整个 undo segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">unlatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_purge_free_segment</span><span class="p">(</span><span class="n">rseg</span><span class="p">,</span> <span class="n">hdr_addr</span><span class="p">,</span> <span class="n">is_temp</span><span class="p">);</span> <span class="c1">// 内部有trx_purge_remove_log_hdr删除history list节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在history list上删除当前 log header（这里相当于我那次一条history的purge）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">trx_purge_remove_log_hdr</span><span class="p">(</span><span class="n">rseg_hdr</span><span class="p">,</span> <span class="n">log_hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">unlatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtr_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 转移到 history list 上的下一条log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mtr_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">is_temp</span><span class="p">)</span> <span class="p">{</span> <span class="n">mtr</span><span class="p">.</span><span class="n">set_log_mode</span><span class="p">(</span><span class="n">MTR_LOG_NO_REDO</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">latch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">rseg_hdr</span> <span class="o">=</span> <span class="n">trx_rsegf_get</span><span class="p">(</span><span class="n">rseg</span><span class="o">-&gt;</span><span class="n">space_id</span><span class="p">,</span> <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">page_no</span><span class="p">,</span> <span class="n">rseg</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">hdr_addr</span> <span class="o">=</span> <span class="n">prev_hdr_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 进行物理文件 truncate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">trx_purge_truncate_marked_undo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// S0. 变量初始化，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S1. 获取 MDL 锁
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">MDL_ticket</span> <span class="o">*</span><span class="n">mdl_ticket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">dd_result</span> <span class="o">=</span> <span class="n">dd_tablespace_get_mdl</span><span class="p">(</span><span class="n">space_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">mdl_ticket</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2. 开始 truncate 操作，切换 undospace
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo</span><span class="o">::</span><span class="n">ddl_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trx_purge_truncate_marked_undo_low</span><span class="p">(</span><span class="n">space_num</span><span class="p">,</span> <span class="n">space_name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo</span><span class="o">::</span><span class="n">ddl_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dd_release_mdl</span><span class="p">(</span><span class="n">mdl_ticket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">MONITOR_INC_TIME</span><span class="p">(</span><span class="n">MONITOR_UNDO_TRUNCATE_MICROSECOND</span><span class="p">,</span> <span class="n">counter_time_truncate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S3. 删除 undo log file，标志 undo truncate 完成
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">x_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">done_logging</span><span class="p">(</span><span class="n">space_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">x_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// S4. 清理环境，something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">trx_purge_truncate_marked_undo_low</span><span class="p">(</span><span class="n">space_id_t</span> <span class="n">space_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                               <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">space_name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.1. 获取环境
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// someting...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.2. 创建 undo 文件，标志 undo truncate 开始
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">dberr_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">undo</span><span class="o">::</span><span class="n">start_logging</span><span class="p">(</span><span class="n">marked_space</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// someting...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.3. 过滤特殊条件，someting...
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.4. 实际 undo space 文件裁剪轮转
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    计算新 undo space id 和 undo space no；
</span></span></span><span class="line"><span class="cl"><span class="cm">    删除+新建 file tablespace（fil_delete_tablespace + fil_ibd_create）；
</span></span></span><span class="line"><span class="cl"><span class="cm">    重新初始化新 tablespace 文件，构建 undo 文件内容；
</span></span></span><span class="line"><span class="cl"><span class="cm">    重新设置相应 undo space 回滚段内存结构体（Rsegs *m_rsegs）
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">trx_undo_truncate_tablespace</span><span class="p">(</span><span class="n">marked_space</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// someting...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.5. 设定此 undo 空间后面的可用状态
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="n">space_id_t</span> <span class="n">new_space_id</span> <span class="o">=</span> <span class="n">marked_space</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">dd_space_states</span> <span class="n">next_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Rsegs</span> <span class="o">*</span><span class="n">marked_rsegs</span> <span class="o">=</span> <span class="n">marked_space</span><span class="o">-&gt;</span><span class="n">rsegs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">marked_rsegs</span><span class="o">-&gt;</span><span class="n">x_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">marked_rsegs</span><span class="o">-&gt;</span><span class="n">is_inactive_explicit</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 由外部手动 inactive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">next_state</span> <span class="o">=</span> <span class="n">DD_SPACE_STATE_EMPTY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">marked_rsegs</span><span class="o">-&gt;</span><span class="n">set_empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 由后台 purge 选择，可被再使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">next_state</span> <span class="o">=</span> <span class="n">DD_SPACE_STATE_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">marked_rsegs</span><span class="o">-&gt;</span><span class="n">set_active</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/******************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">    S2.6. 在 DD 中更新 space ID 和 state 信息
</span></span></span><span class="line"><span class="cl"><span class="cm">  *******************************************************/</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">DD_FAILURE</span> <span class="o">==</span> <span class="n">dd_tablespace_set_id_and_state</span><span class="p">(</span><span class="n">space_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                                   <span class="n">new_space_id</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/mysql/">MySQL</a></li>
      <li><a href="https://mzyee.github.io/tags/undo/">Undo</a></li>
      <li><a href="https://mzyee.github.io/tags/mvcc/">MVCC</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mzyee.github.io/posts/mysql/trx/">
    <span class="title">« 上一页</span>
    <br>
    <span>InnoDB 事务系统和事务执行流程</span>
  </a>
  <a class="next" href="https://mzyee.github.io/posts/mysql/undo/">
    <span class="title">下一页 »</span>
    <br>
    <span>InnoDB Undo Log 代码学习</span>
  </a>
</nav>

  </footer>
<div>
  <div class="pagination__title">
    <span class="pagination__title-h" style="font-size: 20px;">💬 评论</span>
    <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.staticfile.org/twikoo/1.6.25/twikoo.all.min.js"></script>
  <script>
    twikoo.init({
      envId: "https://mzyeee.netlify.app/.netlify/functions/twikoo",  
      el: "#tcomment",
      lang: 'zh-CN',
      region: 'ap-hongkong',
      path: window.TWIKOO_MAGIC_PATH || window.location.pathname,
    });
  </script>
</div>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
