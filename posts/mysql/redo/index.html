<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>InnoDB Redo 日志系统 | MZY&#39;s Blog</title>
<meta name="keywords" content="MySQL, Redo">
<meta name="description" content="InnoDB Redo 日志的前后向流程">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/mysql/redo/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4f68b80af0db3eb7759a35d1bff637bffd115ac309cb14b149caeeb1b7149650.css" integrity="sha256-T2i4CvDbPrd1mjXRv/Y3v/0RWsMJyxSxScrusbcUllA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="InnoDB Redo 日志系统" />
<meta property="og:description" content="InnoDB Redo 日志的前后向流程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/mysql/redo/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-10-30T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="InnoDB Redo 日志系统"/>
<meta name="twitter:description" content="InnoDB Redo 日志的前后向流程"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL",
      "item": "https://mzyee.github.io/posts/mysql/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "InnoDB Redo 日志系统",
      "item": "https://mzyee.github.io/posts/mysql/redo/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "InnoDB Redo 日志系统",
  "name": "InnoDB Redo 日志系统",
  "description": "InnoDB Redo 日志的前后向流程",
  "keywords": [
    "MySQL", "Redo"
  ],
  "articleBody": "1. 前言 InnoDB 的 redo log 模块是保证事务持久性的核心，InnoDB 遵守 WAL 原则保证总是日志先行，即在持久化数据文件时保证其对应的 redo 日志已经写到磁盘，这样在崩溃的情况下，它就可以用于恢复对已修改但尚未刷新到磁盘的页面的修改。本文主要讨论 InnoDB 中 redo 日志的物理组织格式，内存结构及前后向的生成/应用流程。可以参考阅读文档：\n数据库故障恢复机制：ARIES、ARIES/IM InnoDB Redo Log 官方介绍 InnoDB redo log 漫游 庖丁解 InnoDB 之 REDO LOG 2. Redo 日志的物理格式 在 8.0.30 版本前，MySQL 通过 innodb_log_file_size 和 innodb_log_files_in_group 分别控制 redo 文件的大小和数目，文件名为 ib_logfilexx；在 8.0.30 版本后，官方新加了参数 innodb_redo_log_capacity 并允许动态配置 redo 日志的总容量，系统一共维护了 32 个文件名为 #ib_redoxx 和 #ib_redoxx_tmp，具有 _tmp 后缀的文件为空余未使用的文件。redo 日志中的数据是以 append 的形式不断增加，文件中任一位点的数据对应一个永久递增的 LSN 号标志。\n一个 redo 文件首先以 LOG_FILE_HDR_SIZE (2KB = 4*512B) 大小的 file header 开头，包含 header info block、checkpoint 1、encryption info、checkpoint 2 这 4 个block；其中 header info block 记录了一些，4字节的 Log 版本 FORMAT、4字节 LOG_UUID、8字节 START_LSN 标识的当前文件开始LSN、最长32位的 Creator 信息表示当前 mysql 版本。有两个 checkpoint 的原因是通过 double write 机制防止单个 checkpoint 记录因为写盘过程中间 crash 而损坏（现在多数 SSD 支持原子写 4K 粒度）。\n这里需要注意的是在 8.0 之前的版本中，checkpoint_lsn 一定指向一个 mtr record group 的开头，并且该 mtr record 应该被恢复（虽然相关页面仍然可能已被刷写下去）。但从 8.0 开始，由于 recent_closed buffer 的存在，这个值可能指向 record group 中间的某个字节，在这种情况下，恢复应该跳过包含检查点 lsn 的日志记录组并从其下一条开始。redo 文件中写入的 checkpoint_lsn 一定在此 redo 的 lsn 范围。\n接着 file header 的是一个个 OS_FILE_LOG_BLOCK_SIZE (512B) 大小的 log block，包括12字节的 Header (block number + data length + first record offset + checkpoint number)、496个字节的 Body、4字节的 Tailer (checksum)。对于 Header 部分的说明是：\n4字节 Block Number，老版本中 Flush Flag 占用最高位bit标识一次 I/O 的第一个 Block，剩下的31个 bit 是当前 Block 编号 2字节 Data Length，长度为 0 为 未使用 block（reuse 情况下可能无效），长度为 [12 , 508) 表示最后一个未写完的 block， 长度为 512 表示写完整的 block； 2字节 First Record Group Offset，用来指向 Block 中第一个 mtr record group 的开始位置，如果和 Data Length 相同则说明内部没有开启记录新的 mtr record group； 4字节 Epoch Number，和 Block Number 一起组成了 block 的唯一标志，通过 64 位 block start lsn 转换获得。在老版本中，这里记录的是每次刷 checkpoint 时推进的 log_sys-\u003enext_checkpoint_no 的低四位。 在 log block 的 body 部分，则是一条条实际的 redo log record，或者在 InnoDB 中称为 mtr record 更为贴切。每个 redo record 的第一个 Byte 是这个记录的类型，其中最高位的 bit 为 MLOG_SINGLE_REC_FLAG，如果被设置则表示此 mtr 只包含了（最多单个页相关）的单条记录，否则是由多条单 record 组成的 mtr record group，并且在 group 结尾会以 MLOG_MULTI_REC_END标记；之后以压缩格式记录当前 record 对应的 space id 和 page no（除 TABLE_DYNAMIC_META 等类型）；接着是当前 record 对应的 record body 部分内容，具体内容会由 record 的类型决定。\nInnoDB 的 redo 是 Physiological Logging，网上一种常用说法是 “Physical to a page，logical within a page”，实际上可以理解是在记录日志时对前向过程日志记录量和后向日志恢复速度的优化考虑，在对于 page 内的修改日志并非一定是 logical 的，但在对于一个或多个 page 的固定模式的修改可以通过 logical log 来减小 redo 记录量。另外在 undo 相关的分析文章中提到过 undo 表空间数据也是通过 redo 来维护的，而 undo 本身是基于逻辑而非物理去做回滚的。\n3. Redo 日志的生成 首先有必要介绍 InnoDB 中 mtr (mini-transaction) 的概念，InnoDB 中对于物理文件的修改都是以 mtr 作为原子单位（无论其内是 single 还是 multi record 的）。一个 mtr 在前向执行过程中会占据所需的资源，包括 index、page 及其对应物理锁等，以保证并发操作正确性，并将数据修改操作对应生成的 redo 在 mtr 内部缓存。在 mtr commit 的时候此 mtr 会将缓存的 redo record 提交到全局 log buffer 中等待落盘。需要注意的是，在内存逻辑来看（不发生crash情况下）mtr 一旦提交就代表了这个物理操作在系统全局产生持久化效果，哪怕对应所属的 transaction 还没有或最终最终提交，因此这里在必须时就需要 undo mtr 的操作，因此在对应数据操作前都需要先记录 undo；此外，部分物理操作可能不会被撤销，比如空间拓展分配等。\n如果 mtr 产生 redo log 则其在提交过程中：\n根据数据长度向 log_sys 申请对应的全局顺序记录的 sn 范围，其通过加上 block header 和 tailer，不包括 file header 可以转换为对应的 lsn 范围；并且等待到 log buffer 的空间足够对应 sn 范围数据被写入； 对于 mtr 中缓存的所有 redo record，按 log block 的格式将 header 和 tailer 留空 copy body 内容，并将 header 中的 First Record Group Offset 字段（写完后的下一个）填上； 等待至 recent_written link_buf 有空闲位置，表示到这一位置的 lsn 对应的 log 可以被写入；再推进此结构的中相应的 lsn 范围，表示这一段内容已经完整写入到 log buffer 中，并尝试推进其 m_tail（已经连续完整写入到位置）； 等待至 recent_closed link_buf 有空闲位置，表示到这一位置的 lsn 对应的 dirty page 可以被加到 flush list 上；再将 dirty page 挂到 flush list 上； 最终释放所有 page 锁等独占资源。 4. Redo 日志的写入 在 mtr redo record 写入到全局 log buffer 中后，系统通过全局结构 log_t *log_sys 和后台工作线程来写入 redo 日志，并维护如各种 lsn 位点等相关状态。\n后台工作线程有如下这些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 控制 log 文件的轮转 */ void log_files_governor(log_t *log_ptr); /* 将全局 log buffer 中的日志写入到 OS buffer 中 */ void log_writer(log_t *log_ptr); /* 将 OS buffers 中的数据刷写到磁盘上 (fsyncs) */ void log_flusher(log_t *log_ptr); /* 通知用户线程对应 log write 完成，write_lsn 已更新 */ void log_write_notifier(log_t *log_ptr); /* 通知用户线程对应 log flush 完成，flushed_to_disk_lsn 已更新 */ void log_flush_notifier(log_t *log_ptr); /* 检查是否需要要求完成强制刷脏并写入 checkpoint lsn 到日志文件中 */ void log_checkpointer(log_t *log_ptr); 这里刷写相关的任务其实都是围绕 log file 和 log buffer 首位端的推进：\n系统维护了所有的 log file 的内存对象 Log_files_dict，并通过 log_files_governor 控制已写入完全（可 purge 或仍需要）、当前正在写入、后续可使用的 redo 文件状态； log buffer 头部的推进的相关状态，buf_limit_sn（限制可被写入到 buffer 的最大 sn，即 wirte_lsn + buf_size）、recent_written buffer（追踪控制 mtr 并发写入状态 log buffer）、recent_closed buffer（追踪控制 dirty page 挂载 flush list）； log buffer 刷写状态，到 recent_written tail 位置的 redo 已经完整可写盘（这里需要等至上一次 checkpoint 加 redo file 总容量超过目标写入 lsn），log writer 会将 log block 的 header 和 tailer 填充，然后确定写入范围直接从 log buffer（完整 log_write_ahead_size 大小倍数）或通过 write_ahead_buffer（小于 log_write_ahead_size） 写入 log file； log buffer 尾部的推进的相关状态，如 write_lsn、flushed_to_disk_lsn，事件通知等。 checkpoint 推进，并对 log file 尾部文件的回收。 对应线程具体的执行流程介绍可以参考官方文档。 5. Redo 日志应用及 InnoDB 奔溃恢复 在奔溃恢复的情况下，InnoDB通过应用 redo 来恢复已经提交但还没有刷盘的事务数据。另外，一些基于物理复制架构的数据库，像 PolarDB、AWS Aurora 等，还存在通过应用 redo 来进行数据同步的流程。我们这里只讨论 recovery 的 redo 阶段，整个 InnoDB server 的启动简化流程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 dberr_t srv_start(bool create_new_db) { // Step 0. 环境准备和检查，... // Step 1. 初始化 SRV 变量，... srv_boot(); // Step 2. 扫描配置的目录，生成文件map fil_init(innobase_get_open_files_limit()); // 确定路径... // 扫描获取 .IBD 和 undo 文件，从首 page 中读取 space_id 并记录到 fil_system 的 Tablespace_dirs err = fil_scan_for_tablespaces(); // Step 3. INNODB STATUS 监控文件... // Step 4. 初始化 AIO 线程... os_aio_init(srv_n_read_io_threads, srv_n_write_io_threads) // Step 5. 初始化 buffer pool... err = buf_pool_init(srv_buf_pool_size, srv_buf_pool_instances); // Step 6. 初始化多个子系统... fsp_init(); pars_init(); recv_sys_create(); recv_sys_init(); trx_sys_create(); lock_sys_create(srv_lock_table_size); os_aio_start_threads();/* i/o-handler threads */ buf_flush_page_cleaner_init(); // Step 7. 初始化 system tablespace... // ibdata1 文件内含系统表空间（注意与 元数据DD表空间 或叫 内部系统表 的 mysql.ibd 区分） // 内含 change buffer(，特定情况下含用户表、undo 表)等 // 创建对应的 sysspace 并加入 fil_system (fil_space_create + fil_node_create) err = srv_sys_space.open_or_create(false, create_new_db, \u0026sum_of_new_sizes, \u0026flushed_lsn); dict_persist_init(); // Step 8. 初始化 log sys，这里还会扫描出所有 redo file 来构建 Log_files_dict err = log_sys_init(create_new_db, flushed_lsn, new_files_lsn); //... if (create_new_db) { // 初始化建立新 db } else { // Step 9. BP状态重置 err = dblwr::v1::init(); /* 初始化 double write */ buf_pool_invalidate(); /* 淘汰所有 page 确保 recovery 重读 */ // Step 10. 打开所有 log files 和 system data files fil_open_system_tablespace_files(); // Step 11. 开始恢复 redo 日志... err = recv_recovery_from_checkpoint_start(*log_sys, flushed_lsn); // ... 初始化 innodb data dictionary system // Step 12. 启动后台 log 线程 ... if (!srv_read_only_mode) { log_start_background_threads(*log_sys); } // Step 13. 应用剩余的最后一批 hashed log records if (srv_force_recovery \u003c SRV_FORCE_NO_LOG_REDO) { err = recv_apply_hashed_log_recs(*log_sys, !recv_sys-\u003eis_cloned_db \u0026\u0026 !log_upgrade); } // 一些检查... // Step 14. 刷写所有脏页 if (!srv_force_recovery \u0026\u0026 !srv_read_only_mode) { buf_flush_sync_all_buf_pools(); } // Step 15. 完成 redo 日志恢复后的清理，恢复dynamic metadata MetadataRecover *dict_metadata = recv_recovery_from_checkpoint_finish(false); /* 此时 DD（table persistent data）还没有完全 recovery */ if (!recv_sys-\u003eis_cloned_db \u0026\u0026 !dict_metadata-\u003eempty()) { fil_space_t *space = fil_space_acquire_silent(dict_sys_t::s_dict_space_id); if (space == nullptr) { dberr_t error = fil_ibd_open(true, FIL_TYPE_TABLESPACE, dict_sys_t::s_dict_space_id, predefined_flags, dict_sys_t::s_dd_space_name, dict_sys_t::s_dd_space_file_name, true, false); } else { fil_space_release(space); } dict_persist-\u003etable_buffer = ut::new_withkey\u003cDDTableBuffer\u003e(UT_NEW_THIS_FILE_PSI_KEY); dict_metadata-\u003estore(); // 将恢复过程中persistent dynamic metadata修改 store 到 mysql.innodb_dynamic_metadata log_buffer_flush_to_disk(*log_sys); } ut::delete_(dict_metadata); // Step 16. 构建 Undo Tablespaces 和 Rollback Segments 内存结构并进行恢复 err = srv_undo_tablespaces_init(false); trx_purge_sys_mem_create(); purge_queue = trx_sys_init_at_db_start(); srv_undo_tablespaces_upgrade(); trx_purge_sys_initialize(srv_threads.m_purge_workers_n, purge_queue); } /* Open temp-tablespace and keep it open until shutdown. */ err = srv_open_tmp_tablespace(create_new_db, \u0026srv_tmp_space); err = ibt::open_or_create(create_new_db); // Step 17. 完整化 undo 表空间 // 增加 rollback segment 数目到 srv_rollback_segments，此次配置可能和上次不同 trx_rseg_adjust_rollback_segments(srv_rollback_segments); // 构建完成完整 undo 表空间，删除 trunc.log，设置active srv_undo_tablespaces_mark_construction_done(); undo::spaces-\u003es_lock(); for (auto undo_space : undo::spaces-\u003em_spaces) { if (!undo_space-\u003eis_empty()) { undo_space-\u003eset_active(); } } undo::spaces-\u003es_unlock(); // Step 18. 监控系统等... // Step 19. something... return (DB_SUCCESS); } 其中比较关键的阶段在于 Step 11 recv_recovery_from_checkpoint_start 中进行 redo 恢复以及 Step 16 恢复 undo 和 trx 系统的状态，后者在 undo 系统的讨论中进行介绍，本文主要讨论前者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 dberr_t recv_recovery_from_checkpoint_start(log_t \u0026log, lsn_t flush_lsn) { // Step 1. 初始化flush_rbt，保证脏页按序插入flush list buf_flush_init_flush_rbt(); // Step 2. 通过扫描 Log_files_dict 找最后的 checkpoint 记录 Log_checkpoint_location checkpoint; recv_find_max_checkpoint(log, checkpoint); // ... /* Step 3. 解析存储 redo record： 1. 从 checkpoint 读取 redo 文件暂存到 log_sys-\u003ebuf； 2. 按 log block 扫描去 block head/tail 存到 recv_sys-\u003ebuf 中； 3. 将 recv_sys-\u003ebuf 中的记录 parse，生成 recv_t *recv（单个 record）和 recv_addr_t *recv_addr（page 所有 record 串）； 4. 存储 recv_addr_t 到 recv_sys 哈希表对应的 (space_id, page_no) 处 5. （如果占用内存较大）将所有存储的 record apply 到 page 上，bp内的走 recv_recover_page、bp外的走 buf_read_recv_pages */ recv_recovery_begin(log, checkpoint_lsn); // Step 4. 初始化 log_sys 状态，包括各 lsn 位点、各 buf 状态 lsn_t recovered_lsn = log.recovered_lsn = recv_sys-\u003erecovered_lsn; auto check_scanned_lsn = log.m_scanned_lsn; if (check_scanned_lsn % OS_FILE_LOG_BLOCK_SIZE == 0) { // If it is at block boundary, add header size. check_scanned_lsn += LOG_BLOCK_HDR_SIZE; } err = log_start(log, checkpoint_lsn, recovered_lsn, false); if (!srv_read_only_mode) { log.next_checkpoint_header_no = log_next_checkpoint_header(checkpoint.m_checkpoint_header_no); err = log_files_next_checkpoint(log, checkpoint_lsn); } mutex_enter(\u0026recv_sys-\u003emutex); recv_sys-\u003eapply_log_recs = true; mutex_exit(\u0026recv_sys-\u003emutex); return DB_SUCCESS; } 对应 redo 的使用主要在于 parse 和 apply 两个阶段，分别对应 recv_parse_log_recs 和 recv_apply_log_rec 两个接口。parse 阶段完成后 recv_sys 内 redo record hash 的结构层次如下，存储的是对应 (space,page) 的解析完成的 redo record body。\n1 2 3 4 recv_sys =\u003e space_m =\u003e page_x =\u003e recv_addr_t =\u003e recv_t(data1)-\u003erecv_t(data2)-\u003erecv_t(data3) =\u003e page_y =\u003e recv_addr_t =\u003e recv_t(data1)-\u003e... =\u003e ... space_n =\u003e ... 解析的逻辑较为简单，由于 InnoDB 对于单个 redo record 不会记录长度，因此就是通过 redo 类型确定走不同解析逻辑确定 redo record 长度（这里 MariaDB 记录了长度来加速，当然其 redo 内容也还有许多其他修改）。需要注意的是对应一些非物理 page 的 redo (如 MLOG_FILE_EXTEND) 或特殊 page (如 page 0) 元信息修改，在 parse 阶段就会做额外的处理工作来维护状态。\n应用的逻辑触发逻辑有两种，对于 bp 内的 page 直接走 recv_recover_page，对于 bp 外的 page 在读 I/O 完成时 buf_page_io_complete 也是调用 recv_recover_page（唯一不同的是后者会转移 page 的 x-latch 的 ownership 到当前线程）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 void recv_recover_page_func(bool just_read_in, buf_block_t *block) { mutex_enter(\u0026recv_sys-\u003emutex); if (recv_sys-\u003eapply_log_recs == false) { mutex_exit(\u0026recv_sys-\u003emutex); return; } recv_addr_t *recv_addr = recv_get_rec(block-\u003epage.id.space(), block-\u003epage.id.page_no()); if (recv_addr == nullptr || recv_addr-\u003estate == RECV_BEING_PROCESSED || recv_addr-\u003estate == RECV_PROCESSED) { mutex_exit(\u0026recv_sys-\u003emutex); return; } recv_addr-\u003estate = RECV_BEING_PROCESSED; mutex_exit(\u0026recv_sys-\u003emutex); mtr_t mtr; mtr_start(\u0026mtr); mtr_set_log_mode(\u0026mtr, MTR_LOG_NONE); // redo 应用不在记录redo // 获取 page block page_t *page = block-\u003eframe; page_zip_des_t *page_zip = buf_block_get_page_zip(block); if (just_read_in) { rw_lock_x_lock_move_ownership(\u0026block-\u003elock); } bool success = buf_page_get_known_nowait( RW_X_LATCH, block, Cache_hint::KEEP_OLD, __FILE__, __LINE__, \u0026mtr); ut_a(success); // 获取 page lsn lsn_t page_lsn = mach_read_from_8(page + FIL_PAGE_LSN); lsn_t page_newest_lsn = buf_page_get_newest_modification(\u0026block-\u003epage); lsn_t end_lsn = 0; lsn_t start_lsn = 0; bool modification_to_page = false; if (page_newest_lsn) { page_lsn = page_newest_lsn; } for (auto recv : recv_addr-\u003erec_list) { end_lsn = recv-\u003eend_lsn; byte *buf = nullptr; if (recv-\u003elen \u003e RECV_DATA_BLOCK_SIZE) { buf = static_cast\u003cbyte *\u003e(ut::malloc_withkey(UT_NEW_THIS_FILE_PSI_KEY, recv-\u003elen)); recv_data_copy_to_buf(buf, recv); } else if (recv-\u003edata != nullptr) { buf = ((byte *)(recv-\u003edata)) + sizeof(recv_data_t); } if (recv-\u003etype == MLOG_INIT_FILE_PAGE) { // init page 类型先修正 page lsn，相当于第一次会强制做 apply page_lsn = page_newest_lsn; memset(FIL_PAGE_LSN + page, 0, 8); memset(UNIV_PAGE_SIZE - FIL_PAGE_END_LSN_OLD_CHKSUM + page, 0, 8); if (page_zip) memset(FIL_PAGE_LSN + page_zip-\u003edata, 0, 8); } // 过滤条件：1. page lsn 不超过 redo 的 lsn；2. 对于 undo 空间没有 truncate if (recv-\u003estart_lsn \u003e= page_lsn \u0026\u0026 undo::is_active(recv_addr-\u003espace)) { lsn_t end_lsn; unsigned char *buf_end = nullptr; if (!modification_to_page) { modification_to_page = true; start_lsn = recv-\u003estart_lsn; } if (buf != nullptr) { buf_end = buf + recv-\u003elen; } // 这里按照 redo 类型对 page 真正进行数据修改恢复 recv_parse_or_apply_log_rec_body(recv-\u003etype, buf, buf_end, recv_addr-\u003espace, recv_addr-\u003epage_no, block, \u0026mtr, ULINT_UNDEFINED, LSN_MAX); end_lsn = recv-\u003estart_lsn + recv-\u003elen; // 更新 page lsn mach_write_to_8(FIL_PAGE_LSN + page, end_lsn); mach_write_to_8(UNIV_PAGE_SIZE - FIL_PAGE_END_LSN_OLD_CHKSUM + page, end_lsn); if (page_zip) mach_write_to_8(FIL_PAGE_LSN + page_zip-\u003edata, end_lsn); ++applied_recs; } else { ++skipped_recs; } if (recv-\u003elen \u003e RECV_DATA_BLOCK_SIZE) ut::free(buf); } // 有修改要加入脏页 if (modification_to_page) { buf_flush_recv_note_modification(block, start_lsn, end_lsn); } mtr_commit(\u0026mtr); // 更新 recv_sys 状态 mutex_enter(\u0026recv_sys-\u003emutex); if (recv_max_page_lsn \u003c page_lsn) recv_max_page_lsn = page_lsn; recv_addr-\u003estate = RECV_PROCESSED; --recv_sys-\u003en_addrs; mutex_exit(\u0026recv_sys-\u003emutex); } 版权声明：如需转载或引用，请附加本文链接并注明来源。 ",
  "wordCount" : "1829",
  "inLanguage": "zh",
  "datePublished": "2023-10-30T00:00:00Z",
  "dateModified": "2023-10-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/mysql/redo/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title="MZY&#39;s Blog (Alt + H)">
                <img src="https://mzyee.github.io/img/eye.jpeg" alt="" aria-label="logo"
                    height="30">MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/mysql/">MySQL</a></div>
    <h1 class="post-title">
      InnoDB Redo 日志系统
    </h1>
    <div class="post-meta"><span title='2023-10-30 00:00:00 +0000 UTC'>十月 30, 2023</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;Miao Zheyu
      &nbsp;|&nbsp;Tags: &nbsp;
      <ul class="post-tags-meta">
        <a href="https://mzyee.github.io/tags/mysql/">MySQL</a>
        <a href="https://mzyee.github.io/tags/redo/">&nbsp;Redo</a>
      </ul>&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e5%89%8d%e8%a8%80" aria-label="1. 前言">1. 前言</a></li>
                    <li>
                        <a href="#2-redo-%e6%97%a5%e5%bf%97%e7%9a%84%e7%89%a9%e7%90%86%e6%a0%bc%e5%bc%8f" aria-label="2. Redo 日志的物理格式">2. Redo 日志的物理格式</a></li>
                    <li>
                        <a href="#3-redo-%e6%97%a5%e5%bf%97%e7%9a%84%e7%94%9f%e6%88%90" aria-label="3. Redo 日志的生成">3. Redo 日志的生成</a></li>
                    <li>
                        <a href="#4-redo-%e6%97%a5%e5%bf%97%e7%9a%84%e5%86%99%e5%85%a5" aria-label="4. Redo 日志的写入">4. Redo 日志的写入</a></li>
                    <li>
                        <a href="#5-redo-%e6%97%a5%e5%bf%97%e5%ba%94%e7%94%a8%e5%8f%8a-innodb-%e5%a5%94%e6%ba%83%e6%81%a2%e5%a4%8d" aria-label="5. Redo 日志应用及 InnoDB 奔溃恢复">5. Redo 日志应用及 InnoDB 奔溃恢复</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><h3 id="1-前言">1. 前言<a hidden class="anchor" aria-hidden="true" href="#1-前言">#</a></h3>
<p>   InnoDB 的 redo log 模块是保证事务持久性的核心，InnoDB 遵守 WAL 原则保证总是日志先行，即在持久化数据文件时保证其对应的 redo 日志已经写到磁盘，这样在崩溃的情况下，它就可以用于恢复对已修改但尚未刷新到磁盘的页面的修改。本文主要讨论 InnoDB 中 redo 日志的物理组织格式，内存结构及前后向的生成/应用流程。可以参考阅读文档：</p>
<ul>
<li>数据库故障恢复机制：<a href="https://dl.acm.org/doi/pdf/10.1145/128765.128770">ARIES</a>、<a href="https://dl.acm.org/doi/pdf/10.1145/141484.130338">ARIES/IM</a></li>
<li><a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_INNODB_REDO_LOG.html">InnoDB Redo Log 官方介绍</a></li>
<li><a href="http://mysql.taobao.org/monthly/2015/05/01/">InnoDB redo log 漫游</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109417488">庖丁解 InnoDB 之 REDO LOG</a></li>
</ul>
<!-- Redo 日志的物理格式 -->
<h3 id="2-redo-日志的物理格式">2. Redo 日志的物理格式<a hidden class="anchor" aria-hidden="true" href="#2-redo-日志的物理格式">#</a></h3>
<p>   在 8.0.30 版本前，MySQL 通过 innodb_log_file_size 和 innodb_log_files_in_group 分别控制 redo 文件的大小和数目，文件名为 <code>ib_logfilexx</code>；在 8.0.30 版本后，官方新加了参数 innodb_redo_log_capacity 并允许动态配置 redo 日志的总容量，系统一共维护了 32 个文件名为 <code>#ib_redoxx</code> 和 <code>#ib_redoxx_tmp</code>，具有 <code>_tmp</code> 后缀的文件为空余未使用的文件。redo 日志中的数据是以 append 的形式不断增加，文件中任一位点的数据对应一个永久递增的 LSN 号标志。</p>
<p>   一个 redo 文件首先以 <code>LOG_FILE_HDR_SIZE (2KB = 4*512B)</code> 大小的 file header 开头，包含 <strong>header info block</strong>、<strong>checkpoint 1</strong>、<strong>encryption info</strong>、<strong>checkpoint 2</strong> 这 4 个block；其中 header info block 记录了一些，4字节的 Log 版本 FORMAT、4字节 LOG_UUID、8字节 START_LSN 标识的当前文件开始LSN、最长32位的 Creator 信息表示当前 mysql 版本。有两个 checkpoint 的原因是通过 double write 机制防止单个 checkpoint 记录因为写盘过程中间 crash 而损坏（现在多数 SSD 支持原子写 4K 粒度）。</p>
<p>   这里需要注意的是在 8.0 之前的版本中，checkpoint_lsn 一定指向一个 mtr record group 的开头，并且该 mtr record 应该被恢复（虽然相关页面仍然可能已被刷写下去）。但从 8.0 开始，由于 recent_closed buffer 的存在，这个值可能指向 record group 中间的某个字节，在这种情况下，恢复应该跳过包含检查点 lsn 的日志记录组并从其下一条开始。redo 文件中写入的 checkpoint_lsn 一定在此 redo 的 lsn 范围。</p>
<p>   接着 file header 的是一个个 <code>OS_FILE_LOG_BLOCK_SIZE (512B)</code> 大小的 log block，包括12字节的 Header (block number + data length + first record offset + checkpoint number)、496个字节的 Body、4字节的 Tailer (checksum)。对于 Header 部分的说明是：</p>
<ul>
<li><strong>4字节 Block Number</strong>，老版本中 Flush Flag 占用最高位bit标识一次 I/O 的第一个 Block，剩下的31个 bit 是当前 Block 编号</li>
<li><strong>2字节 Data Length</strong>，长度为 0 为 未使用 block（reuse 情况下可能无效），长度为 [12 , 508) 表示最后一个未写完的 block， 长度为 512 表示写完整的 block；</li>
<li><strong>2字节 First Record Group Offset</strong>，用来指向 Block 中第一个 mtr record group 的开始位置，如果和 Data Length 相同则说明内部没有开启记录新的 mtr record group；</li>
<li><strong>4字节 Epoch Number</strong>，和 Block Number 一起组成了 block 的唯一标志，通过 64 位 block start lsn 转换获得。在老版本中，这里记录的是每次刷 checkpoint 时推进的 log_sys-&gt;next_checkpoint_no 的低四位。</li>
</ul>
<p>   在 log block 的 body 部分，则是一条条实际的 redo log record，或者在 InnoDB 中称为 mtr record 更为贴切。每个 redo record 的第一个 Byte 是这个<strong>记录的类型</strong>，其中最高位的 bit 为 <strong>MLOG_SINGLE_REC_FLAG</strong>，如果被设置则表示此 mtr 只包含了（最多单个页相关）的单条记录，否则是由多条单 record 组成的 mtr record group，并且在 group 结尾会以 <strong>MLOG_MULTI_REC_END</strong>标记；之后以压缩格式记录当前 record <strong>对应的 space id 和 page no</strong>（除 TABLE_DYNAMIC_META 等类型）；接着是当前 record 对应的 <strong>record body</strong> 部分内容，具体内容会由 record 的类型决定。</p>
<p>   InnoDB 的 redo 是 Physiological Logging，网上一种常用说法是 “Physical to a page，logical within a page”，实际上可以理解是在记录日志时对前向过程日志记录量和后向日志恢复速度的优化考虑，在对于 page 内的修改日志并非一定是 logical 的，但在对于一个或多个 page 的固定模式的修改可以通过 logical log 来减小 redo 记录量。另外在 undo 相关的分析文章中提到过 undo 表空间数据也是通过 redo 来维护的，而 undo 本身是基于逻辑而非物理去做回滚的。</p>
<!-- Redo 日志的生成 -->
<h3 id="3-redo-日志的生成">3. Redo 日志的生成<a hidden class="anchor" aria-hidden="true" href="#3-redo-日志的生成">#</a></h3>
<p>   首先有必要介绍 InnoDB 中 mtr (mini-transaction) 的概念，InnoDB 中对于物理文件的修改都是以 mtr 作为<strong>原子单位</strong>（无论其内是 single 还是 multi record 的）。一个 mtr 在前向执行过程中会占据所需的资源，包括 index、page 及其对应物理锁等，以保证并发操作正确性，并将数据修改操作对应生成的 redo 在 mtr 内部缓存。在 mtr commit 的时候此 mtr 会将缓存的 redo record 提交到全局 log buffer 中等待落盘。需要注意的是，在内存逻辑来看（不发生crash情况下）mtr 一旦提交就代表了这个物理操作在系统全局产生持久化效果，哪怕对应所属的 transaction 还没有或最终最终提交，因此这里在必须时就需要 undo mtr 的操作，因此在对应数据操作前都需要先记录 undo；此外，部分物理操作可能不会被撤销，比如空间拓展分配等。</p>
<p>   如果 mtr 产生 redo log 则其在提交过程中：</p>
<ul>
<li>根据数据长度向 log_sys <strong>申请</strong>对应的全局顺序记录的 <strong>sn 范围</strong>，其通过加上 block header 和 tailer，不包括 file header 可以转换为对应的 lsn 范围；并且等待到 log buffer 的<strong>空间足够</strong>对应 sn 范围数据被写入；</li>
<li>对于 mtr 中缓存的所有 redo record，按 log block 的格式将 header 和 tailer 留空 <strong>copy body</strong> 内容，并将 header 中的 First Record Group Offset 字段（写完后的下一个）填上；</li>
<li>等待至 <strong>recent_written</strong> link_buf 有空闲位置，表示到这一位置的 lsn 对应的 log 可以被写入；再推进此结构的中相应的 lsn 范围，表示这一段内容已经完整写入到 log buffer 中，并尝试推进其 m_tail（已经连续完整写入到位置）；</li>
<li>等待至 <strong>recent_closed</strong> link_buf 有空闲位置，表示到这一位置的 lsn 对应的 dirty page 可以被加到 flush list 上；再将 dirty page 挂到  flush list 上；</li>
<li>最终释放所有 page 锁等独占资源。</li>
</ul>
<!-- Redo 日志的写入 -->
<h3 id="4-redo-日志的写入">4. Redo 日志的写入<a hidden class="anchor" aria-hidden="true" href="#4-redo-日志的写入">#</a></h3>
<p><img loading="lazy" src="redo_write.png" alt="redo_write"  />

   在 mtr redo record 写入到全局 log buffer 中后，系统通过全局结构 log_t *log_sys 和后台工作线程来写入 redo 日志，并维护如各种 lsn 位点等相关状态。</p>
<p>   后台工作线程有如下这些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* 控制 log 文件的轮转 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_files_governor</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 将全局 log buffer 中的日志写入到 OS buffer 中 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_writer</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 将 OS buffers 中的数据刷写到磁盘上 (fsyncs) */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_flusher</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 通知用户线程对应 log write 完成，write_lsn 已更新 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_write_notifier</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 通知用户线程对应 log flush 完成，flushed_to_disk_lsn 已更新 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_flush_notifier</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 检查是否需要要求完成强制刷脏并写入 checkpoint lsn 到日志文件中 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">log_checkpointer</span><span class="p">(</span><span class="n">log_t</span> <span class="o">*</span><span class="n">log_ptr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   这里刷写相关的任务其实都是围绕 log file 和 log buffer 首位端的推进：</p>
<ul>
<li>系统维护了所有的 <strong>log file</strong> 的内存对象 Log_files_dict，并通过 log_files_governor 控制已写入完全（可 purge 或仍需要）、当前正在写入、后续可使用的 redo 文件状态；</li>
<li><strong>log buffer 头部</strong>的推进的相关状态，buf_limit_sn（限制可被写入到 buffer 的最大 sn，即 wirte_lsn + buf_size）、recent_written buffer（追踪控制 mtr 并发写入状态 log buffer）、recent_closed buffer（追踪控制 dirty page 挂载 flush list）；</li>
<li><strong>log buffer 刷写</strong>状态，到 recent_written tail 位置的 redo 已经完整可写盘（这里需要等至上一次 checkpoint 加 redo file 总容量超过目标写入 lsn），log writer 会将 log block 的 header 和 tailer 填充，然后确定写入范围直接从 log buffer（完整 log_write_ahead_size 大小倍数）或通过 <strong>write_ahead_buffer</strong>（小于 log_write_ahead_size） 写入 log file；</li>
<li><strong>log buffer 尾部</strong>的推进的相关状态，如 write_lsn、flushed_to_disk_lsn，事件通知等。</li>
<li><strong>checkpoint 推进</strong>，并对 log file 尾部文件的回收。
对应线程具体的执行流程介绍可以参考<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_INNODB_REDO_LOG_THREADS.html">官方文档</a>。</li>
</ul>
<!-- Redo 日志的应用 -->
<h3 id="5-redo-日志应用及-innodb-奔溃恢复">5. Redo 日志应用及 InnoDB 奔溃恢复<a hidden class="anchor" aria-hidden="true" href="#5-redo-日志应用及-innodb-奔溃恢复">#</a></h3>
<p>   在奔溃恢复的情况下，InnoDB通过应用 redo 来恢复已经提交但还没有刷盘的事务数据。另外，一些基于物理复制架构的数据库，像 <a href="https://www.alibabacloud.com/zh/product/polardb-for-mysql">PolarDB</a>、AWS Aurora 等，还存在通过应用 redo 来进行数据同步的流程。我们这里只讨论 recovery 的 redo 阶段，整个 InnoDB server 的启动简化流程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">srv_start</span><span class="p">(</span><span class="kt">bool</span> <span class="n">create_new_db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 0. 环境准备和检查，...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Step 1. 初始化 SRV 变量，...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">srv_boot</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 2. 扫描配置的目录，生成文件map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">fil_init</span><span class="p">(</span><span class="n">innobase_get_open_files_limit</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 确定路径...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 扫描获取 .IBD 和 undo 文件，从首 page 中读取 space_id 并记录到 fil_system 的 Tablespace_dirs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">err</span> <span class="o">=</span> <span class="n">fil_scan_for_tablespaces</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 3. INNODB STATUS 监控文件...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 4. 初始化 AIO 线程...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">os_aio_init</span><span class="p">(</span><span class="n">srv_n_read_io_threads</span><span class="p">,</span> <span class="n">srv_n_write_io_threads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 5. 初始化 buffer pool...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">err</span> <span class="o">=</span> <span class="n">buf_pool_init</span><span class="p">(</span><span class="n">srv_buf_pool_size</span><span class="p">,</span> <span class="n">srv_buf_pool_instances</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 6. 初始化多个子系统...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">fsp_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pars_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_sys_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_sys_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">trx_sys_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_sys_create</span><span class="p">(</span><span class="n">srv_lock_table_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">os_aio_start_threads</span><span class="p">();</span><span class="cm">/* i/o-handler threads */</span>
</span></span><span class="line"><span class="cl">  <span class="n">buf_flush_page_cleaner_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 7. 初始化 system tablespace...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ibdata1 文件内含系统表空间（注意与 元数据DD表空间 或叫 内部系统表 的 mysql.ibd 区分）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 内含 change buffer(，特定情况下含用户表、undo 表)等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 创建对应的 sysspace 并加入 fil_system (fil_space_create + fil_node_create)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">err</span> <span class="o">=</span> <span class="n">srv_sys_space</span><span class="p">.</span><span class="n">open_or_create</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">create_new_db</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="o">&amp;</span><span class="n">sum_of_new_sizes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flushed_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">dict_persist_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 8. 初始化 log sys，这里还会扫描出所有 redo file 来构建 Log_files_dict
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">err</span> <span class="o">=</span> <span class="n">log_sys_init</span><span class="p">(</span><span class="n">create_new_db</span><span class="p">,</span> <span class="n">flushed_lsn</span><span class="p">,</span> <span class="n">new_files_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">create_new_db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 初始化建立新 db
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 9. BP状态重置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">dblwr</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">init</span><span class="p">();</span> <span class="cm">/* 初始化 double write */</span>
</span></span><span class="line"><span class="cl">    <span class="n">buf_pool_invalidate</span><span class="p">();</span> <span class="cm">/* 淘汰所有 page 确保 recovery 重读 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 10. 打开所有 log files 和 system data files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fil_open_system_tablespace_files</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 11. 开始恢复 redo 日志...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">recv_recovery_from_checkpoint_start</span><span class="p">(</span><span class="o">*</span><span class="n">log_sys</span><span class="p">,</span> <span class="n">flushed_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 初始化 innodb data dictionary system
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 12. 启动后台 log 线程 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">srv_read_only_mode</span><span class="p">)</span> <span class="p">{</span> <span class="n">log_start_background_threads</span><span class="p">(</span><span class="o">*</span><span class="n">log_sys</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 13. 应用剩余的最后一批 hashed log records
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">srv_force_recovery</span> <span class="o">&lt;</span> <span class="n">SRV_FORCE_NO_LOG_REDO</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">err</span> <span class="o">=</span> <span class="n">recv_apply_hashed_log_recs</span><span class="p">(</span><span class="o">*</span><span class="n">log_sys</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="o">!</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">is_cloned_db</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">log_upgrade</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 一些检查...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 14. 刷写所有脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">srv_force_recovery</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">srv_read_only_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf_flush_sync_all_buf_pools</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 15. 完成 redo 日志恢复后的清理，恢复dynamic metadata
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">MetadataRecover</span> <span class="o">*</span><span class="n">dict_metadata</span> <span class="o">=</span> <span class="n">recv_recovery_from_checkpoint_finish</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 此时 DD（table persistent data）还没有完全 recovery */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">is_cloned_db</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dict_metadata</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">fil_space_t</span> <span class="o">*</span><span class="n">space</span> <span class="o">=</span> <span class="n">fil_space_acquire_silent</span><span class="p">(</span><span class="n">dict_sys_t</span><span class="o">::</span><span class="n">s_dict_space_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dberr_t</span> <span class="n">error</span> <span class="o">=</span> <span class="n">fil_ibd_open</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">FIL_TYPE_TABLESPACE</span><span class="p">,</span> <span class="n">dict_sys_t</span><span class="o">::</span><span class="n">s_dict_space_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">predefined_flags</span><span class="p">,</span> <span class="n">dict_sys_t</span><span class="o">::</span><span class="n">s_dd_space_name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">dict_sys_t</span><span class="o">::</span><span class="n">s_dd_space_file_name</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">fil_space_release</span><span class="p">(</span><span class="n">space</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">dict_persist</span><span class="o">-&gt;</span><span class="n">table_buffer</span> <span class="o">=</span> <span class="n">ut</span><span class="o">::</span><span class="n">new_withkey</span><span class="o">&lt;</span><span class="n">DDTableBuffer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UT_NEW_THIS_FILE_PSI_KEY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">dict_metadata</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">();</span> <span class="c1">// 将恢复过程中persistent dynamic metadata修改 store 到 mysql.innodb_dynamic_metadata
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">log_buffer_flush_to_disk</span><span class="p">(</span><span class="o">*</span><span class="n">log_sys</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ut</span><span class="o">::</span><span class="n">delete_</span><span class="p">(</span><span class="n">dict_metadata</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 16. 构建 Undo Tablespaces 和 Rollback Segments 内存结构并进行恢复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">srv_undo_tablespaces_init</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_purge_sys_mem_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">purge_queue</span> <span class="o">=</span> <span class="n">trx_sys_init_at_db_start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">srv_undo_tablespaces_upgrade</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">trx_purge_sys_initialize</span><span class="p">(</span><span class="n">srv_threads</span><span class="p">.</span><span class="n">m_purge_workers_n</span><span class="p">,</span> <span class="n">purge_queue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Open temp-tablespace and keep it open until shutdown. */</span>
</span></span><span class="line"><span class="cl">  <span class="n">err</span> <span class="o">=</span> <span class="n">srv_open_tmp_tablespace</span><span class="p">(</span><span class="n">create_new_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srv_tmp_space</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">err</span> <span class="o">=</span> <span class="n">ibt</span><span class="o">::</span><span class="n">open_or_create</span><span class="p">(</span><span class="n">create_new_db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 17. 完整化 undo 表空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 增加 rollback segment 数目到 srv_rollback_segments，此次配置可能和上次不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">trx_rseg_adjust_rollback_segments</span><span class="p">(</span><span class="n">srv_rollback_segments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 构建完成完整 undo 表空间，删除 trunc.log，设置active
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">srv_undo_tablespaces_mark_construction_done</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">undo_space</span> <span class="p">:</span> <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">m_spaces</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">undo_space</span><span class="o">-&gt;</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span> <span class="n">undo_space</span><span class="o">-&gt;</span><span class="n">set_active</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">undo</span><span class="o">::</span><span class="n">spaces</span><span class="o">-&gt;</span><span class="n">s_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 18. 监控系统等...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 19. something...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">DB_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   其中比较关键的阶段在于 Step 11 <code>recv_recovery_from_checkpoint_start</code> 中进行 redo 恢复以及 Step 16 恢复 undo 和 trx 系统的状态，后者在 <a href="/posts/mysql/undo">undo 系统</a>的讨论中进行介绍，本文主要讨论前者。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">dberr_t</span> <span class="nf">recv_recovery_from_checkpoint_start</span><span class="p">(</span><span class="n">log_t</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="n">lsn_t</span> <span class="n">flush_lsn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 1. 初始化flush_rbt，保证脏页按序插入flush list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">buf_flush_init_flush_rbt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 2. 通过扫描 Log_files_dict 找最后的 checkpoint 记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Log_checkpoint_location</span> <span class="n">checkpoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_find_max_checkpoint</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">checkpoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Step 3. 解析存储 redo record：
</span></span></span><span class="line"><span class="cl"><span class="cm">    1. 从 checkpoint 读取 redo 文件暂存到 log_sys-&gt;buf；
</span></span></span><span class="line"><span class="cl"><span class="cm">    2. 按 log block 扫描去 block head/tail 存到 recv_sys-&gt;buf 中；
</span></span></span><span class="line"><span class="cl"><span class="cm">    3. 将 recv_sys-&gt;buf 中的记录 parse，生成 recv_t *recv（单个 record）和 recv_addr_t *recv_addr（page 所有 record 串）；
</span></span></span><span class="line"><span class="cl"><span class="cm">    4. 存储 recv_addr_t 到 recv_sys 哈希表对应的 (space_id, page_no) 处
</span></span></span><span class="line"><span class="cl"><span class="cm">    5. （如果占用内存较大）将所有存储的 record apply 到 page 上，bp内的走 recv_recover_page、bp外的走 buf_read_recv_pages
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_recovery_begin</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">checkpoint_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Step 4. 初始化 log_sys 状态，包括各 lsn 位点、各 buf 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">lsn_t</span> <span class="n">recovered_lsn</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">recovered_lsn</span> <span class="o">=</span> <span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">recovered_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">check_scanned_lsn</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">m_scanned_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">check_scanned_lsn</span> <span class="o">%</span> <span class="n">OS_FILE_LOG_BLOCK_SIZE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If it is at block boundary, add header size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">check_scanned_lsn</span> <span class="o">+=</span> <span class="n">LOG_BLOCK_HDR_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">err</span> <span class="o">=</span> <span class="n">log_start</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">checkpoint_lsn</span><span class="p">,</span> <span class="n">recovered_lsn</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">srv_read_only_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">next_checkpoint_header_no</span> <span class="o">=</span> <span class="n">log_next_checkpoint_header</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">.</span><span class="n">m_checkpoint_header_no</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">log_files_next_checkpoint</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">checkpoint_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mutex_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">apply_log_recs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">DB_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   对应 redo 的使用主要在于 parse 和 apply 两个阶段，分别对应 <code>recv_parse_log_recs</code> 和 <code>recv_apply_log_rec</code> 两个接口。parse 阶段完成后 recv_sys 内 redo record hash 的结构层次如下，存储的是对应 (space,page) 的解析完成的 redo record body。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">recv_sys =&gt; space_m =&gt; page_x =&gt; recv_addr_t =&gt; recv_t(data1)-&gt;recv_t(data2)-&gt;recv_t(data3)
</span></span><span class="line"><span class="cl">                    =&gt; page_y =&gt; recv_addr_t =&gt; recv_t(data1)-&gt;...
</span></span><span class="line"><span class="cl">                    =&gt; ...
</span></span><span class="line"><span class="cl">            space_n =&gt; ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>   解析的逻辑较为简单，由于 InnoDB 对于单个 redo record 不会记录长度，因此就是通过 redo 类型确定走不同解析逻辑确定 redo record 长度（这里 MariaDB 记录了长度来加速，当然其 redo 内容也还有许多其他修改）。需要注意的是对应一些非物理 page 的 redo (如 MLOG_FILE_EXTEND) 或特殊 page (如 page 0) 元信息修改，在 parse 阶段就会做额外的处理工作来维护状态。</p>
<p>   应用的逻辑触发逻辑有两种，对于 bp 内的 page 直接走 <code>recv_recover_page</code>，对于 bp 外的 page 在读 I/O 完成时 <code>buf_page_io_complete</code> 也是调用 <code>recv_recover_page</code>（唯一不同的是后者会转移 page 的 x-latch 的 ownership 到当前线程）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">recv_recover_page_func</span><span class="p">(</span><span class="kt">bool</span> <span class="n">just_read_in</span><span class="p">,</span> <span class="n">buf_block_t</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">apply_log_recs</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">recv_addr_t</span> <span class="o">*</span><span class="n">recv_addr</span> <span class="o">=</span> <span class="n">recv_get_rec</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">space</span><span class="p">(),</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">page_no</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">recv_addr</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RECV_BEING_PROCESSED</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RECV_PROCESSED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RECV_BEING_PROCESSED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mtr_t</span> <span class="n">mtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mtr_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mtr_set_log_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">,</span> <span class="n">MTR_LOG_NONE</span><span class="p">);</span> <span class="c1">// redo 应用不在记录redo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 获取 page block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">page_t</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">page_zip_des_t</span> <span class="o">*</span><span class="n">page_zip</span> <span class="o">=</span> <span class="n">buf_block_get_page_zip</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">just_read_in</span><span class="p">)</span> <span class="p">{</span> <span class="n">rw_lock_x_lock_move_ownership</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">buf_page_get_known_nowait</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">RW_X_LATCH</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">Cache_hint</span><span class="o">::</span><span class="n">KEEP_OLD</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ut_a</span><span class="p">(</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取 page lsn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">lsn_t</span> <span class="n">page_lsn</span> <span class="o">=</span> <span class="n">mach_read_from_8</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">FIL_PAGE_LSN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">lsn_t</span> <span class="n">page_newest_lsn</span> <span class="o">=</span> <span class="n">buf_page_get_newest_modification</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">lsn_t</span> <span class="n">end_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lsn_t</span> <span class="n">start_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">modification_to_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">page_newest_lsn</span><span class="p">)</span> <span class="p">{</span> <span class="n">page_lsn</span> <span class="o">=</span> <span class="n">page_newest_lsn</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">recv</span> <span class="p">:</span> <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">rec_list</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">end_lsn</span> <span class="o">=</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">end_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">byte</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">RECV_DATA_BLOCK_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">byte</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ut</span><span class="o">::</span><span class="n">malloc_withkey</span><span class="p">(</span><span class="n">UT_NEW_THIS_FILE_PSI_KEY</span><span class="p">,</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">recv_data_copy_to_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">recv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf</span> <span class="o">=</span> <span class="p">((</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recv_data_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">MLOG_INIT_FILE_PAGE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// init page 类型先修正 page lsn，相当于第一次会强制做 apply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">page_lsn</span> <span class="o">=</span> <span class="n">page_newest_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">FIL_PAGE_LSN</span> <span class="o">+</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">UNIV_PAGE_SIZE</span> <span class="o">-</span> <span class="n">FIL_PAGE_END_LSN_OLD_CHKSUM</span> <span class="o">+</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">page_zip</span><span class="p">)</span> <span class="n">memset</span><span class="p">(</span><span class="n">FIL_PAGE_LSN</span> <span class="o">+</span> <span class="n">page_zip</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 过滤条件：1. page lsn 不超过 redo 的 lsn；2. 对于 undo 空间没有 truncate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">start_lsn</span> <span class="o">&gt;=</span> <span class="n">page_lsn</span> <span class="o">&amp;&amp;</span> <span class="n">undo</span><span class="o">::</span><span class="n">is_active</span><span class="p">(</span><span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">space</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">lsn_t</span> <span class="n">end_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf_end</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modification_to_page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">modification_to_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">start_lsn</span> <span class="o">=</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">start_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">buf_end</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 这里按照 redo 类型对 page 真正进行数据修改恢复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">recv_parse_or_apply_log_rec_body</span><span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">space</span><span class="p">,</span> <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">page_no</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtr</span><span class="p">,</span> <span class="n">ULINT_UNDEFINED</span><span class="p">,</span> <span class="n">LSN_MAX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">end_lsn</span> <span class="o">=</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">start_lsn</span> <span class="o">+</span> <span class="n">recv</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 更新 page lsn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mach_write_to_8</span><span class="p">(</span><span class="n">FIL_PAGE_LSN</span> <span class="o">+</span> <span class="n">page</span><span class="p">,</span> <span class="n">end_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">mach_write_to_8</span><span class="p">(</span><span class="n">UNIV_PAGE_SIZE</span> <span class="o">-</span> <span class="n">FIL_PAGE_END_LSN_OLD_CHKSUM</span> <span class="o">+</span> <span class="n">page</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">end_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">page_zip</span><span class="p">)</span> <span class="n">mach_write_to_8</span><span class="p">(</span><span class="n">FIL_PAGE_LSN</span> <span class="o">+</span> <span class="n">page_zip</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">end_lsn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">applied_recs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">skipped_recs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">recv</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">RECV_DATA_BLOCK_SIZE</span><span class="p">)</span> <span class="n">ut</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 有修改要加入脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">modification_to_page</span><span class="p">)</span> <span class="p">{</span> <span class="n">buf_flush_recv_note_modification</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">start_lsn</span><span class="p">,</span> <span class="n">end_lsn</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mtr_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新 recv_sys 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mutex_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">recv_max_page_lsn</span> <span class="o">&lt;</span> <span class="n">page_lsn</span><span class="p">)</span> <span class="n">recv_max_page_lsn</span> <span class="o">=</span> <span class="n">page_lsn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">recv_addr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RECV_PROCESSED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">--</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">n_addrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_sys</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/mysql/">MySQL</a></li>
      <li><a href="https://mzyee.github.io/tags/redo/">Redo</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mzyee.github.io/posts/mysql/meta/">
    <span class="title">« 上一页</span>
    <br>
    <span>MySQL 如何准备开启一个表</span>
  </a>
  <a class="next" href="https://mzyee.github.io/posts/mysql/trx/">
    <span class="title">下一页 »</span>
    <br>
    <span>InnoDB 事务系统和事务执行流程</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
