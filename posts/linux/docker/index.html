<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker 简介 | MZY&#39;s Blog</title>
<meta name="keywords" content="docker">
<meta name="description" content="Docker 简介">
<meta name="author" content="Miao Zheyu">
<link rel="canonical" href="https://mzyee.github.io/posts/linux/docker/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.78ed8947c1508d00bdf7a3061370dcaebcd4ba680f4567ec440d26a4043b4e64.css" integrity="sha256-eO2JR8FQjQC996MGE3DcrrzUumgPRWfsRA0mpAQ7TmQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mzyee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mzyee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mzyee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mzyee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mzyee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<meta property="og:title" content="Docker 简介" />
<meta property="og:description" content="Docker 简介" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mzyee.github.io/posts/linux/docker/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-08T10:52:08+08:00" />
<meta property="article:modified_time" content="2024-03-08T10:52:08+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker 简介"/>
<meta name="twitter:description" content="Docker 简介"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mzyee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Docker 简介",
      "item": "https://mzyee.github.io/posts/linux/docker/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker 简介",
  "name": "Docker 简介",
  "description": "Docker 简介",
  "keywords": [
    "docker"
  ],
  "articleBody": " 1. Docker 介绍 “Docker is a platform designed to help developers build, share, and run container applications.”\nDocker daemon (dockerd)： Docker 守护进程，侦听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和卷。守护进程还可以与其他守护进程通信来管理 Docker 服务。\nDocker client (docker)： Docker 客户端，是许多 Docker 用户与 Docker 交互的主要方式。当使用诸如 docker run 命令时，client 会将这些命令发送到 dockerd，由后者执行这些命令。docker 命令使用的 Docker API。Docker 客户端可以与多个守护进程通信。\nDocker registries： Docker 仓库用于存储 Docker 镜像 (images)。Docker Hub 是任何人都可以使用的公共仓库，Docker 默认在 Docker Hub 上查找镜像。用户可以运行自己的私人仓库。当使用 docker pull 或 docker run 命令时，Docker 从配置的仓库中提取所需的镜像。当使用该 docker push 命令时，Docker 会将的镜像推送到配置的仓库。\nDocker objects： 使用 Docker 时 实际上是在创建和使用镜像、容器、网络、存储卷、插件等对象。\n镜像（Image） 是用于创建 docker 容器的模板程序，包含了运行应用所需的所有东西 —— 包括代码、二进制脚本、依赖库、环境变量和配置文件等等。 容器（Container） 是镜像的运行实例，它在隔离的环境中运行不与主机其他容器共享状态，可以使用 Docker API 创建、启动、停止、移动或删除容器，也可以将容器连接到一个或多个网络，为其附加存储，甚至可以根据其当前状态创建一个新的镜像。它与该宿主机上运行的所有其他进程隔离开来，这种隔离利用了内核名称空间和cgroups。 存储 在 docker 中，存储是管理和持久化数据的关键组成部分。Docker 为数据存储和管理提供了几种机制，主要是通过卷（volumes）、绑定挂载（bind mounts）和临时文件系统（tmpfs mounts）。Docker提供了卷和绑定挂载两种选项（对应不同存储定义区），使得容器可以将文件存储在宿主机上，这样即使容器停止文件也会持久保存。docker 还支持容器将临时文件存储在宿主机的内存中，这类文件不会被持久保存。 网络 容器网络指的是容器之间能够连接和通信，或者与非 docker 工作负载通信的能力。容器默认启用了网络功能可以建立外部连接，容器不知道自己连接到了什么类型的网络，只看到一个带有 IP 地址、网关、路由表、DNS 服务和其他网络详细信息的网络接口。Docker 提供了几种不同的网络驱动程序，每种驱动程序都支持不同的用例和网络操作模式，默认使用 bridge 类型驱动，它在没有指定网络的容器时会自动连接到本地主机上的一个私有内部网络。 2. Docker 使用基础 2.1 安装 以 CentOS 为例，安装、启动 docker\n1 2 3 4 sudo yum install -y yum-utils # 设置 docker 目标仓库并且从仓库安装 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 1 2 3 # 启动Docker服务并设置为开机启动 sudo systemctl start docker sudo systemctl enable docker 默认情况下，只有root用户和sudoer才可以运行Docker命令。为了避免每次都使用sudo，可以将用户添加到docker组。\n1 sudo usermod -aG docker ${USER} 2.2 运行容器 通过 docker run 可以运行已有镜像创建一个新的容器，并且在创建容器后会立即启动它。docker create 命令也可以创建容器但不启动，创建容器后可以使用 docker start 命令启动。\n1 2 3 4 docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] # [OPTIONS] 是容器的相关配置信息 # IMAGE[:TAG|@DIGEST] 是镜像标志名 # [COMMAND] [ARG...] 是设定容器启动后运行的命令 常见的可选运行 [OPTIONS] 有\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ### 存储卷 --mount source=,target=[PATH] #绑定 Volume，source 是 volume name，target 是容器内的挂载路径 --mount type=bind,source=[PATH],target=[PATH] # 创建 Bind mounts，source 是 host 路径，target 是容器内的 bind 路径 -v/--volume host-src:container-dest[:options] # Volume/Bind mounts 都可以用这个命令挂载，效果与上面相同 ### 网络设置 --network NETWORK_NAME # NETWORK_NAME 是事先用户创建的网络 --network container:",
  "wordCount" : "847",
  "inLanguage": "zh",
  "datePublished": "2024-03-08T10:52:08+08:00",
  "dateModified": "2024-03-08T10:52:08+08:00",
  "author":{
    "@type": "Person",
    "name": "Miao Zheyu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mzyee.github.io/posts/linux/docker/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "MZY's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mzyee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mzyee.github.io" accesskey="h" title=" MZY&#39;s Blog (Alt + H)">
                <img src="https://mzyee.github.io/img/eye.jpg" alt="" aria-label="logo"
                    height="38"> MZY&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mzyee.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://mzyee.github.io/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mzyee.github.io">主页</a>&nbsp;»&nbsp;<a href="https://mzyee.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Docker 简介
    </h1>
    <div class="post-meta"><span title='2024-03-08 10:52:08 +0800 CST'>三月 8, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Miao Zheyu
      &nbsp;|&nbsp;📖 &nbsp;
      <ul class="post-tags-meta">
        <a href="https://mzyee.github.io/tags/docker/">docker</a>
      </ul>&nbsp;|&nbsp;<a href="https://github.com/mzyee/mzyee.github.io" rel="noopener noreferrer" target="_blank">Suggestions</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-docker-%e4%bb%8b%e7%bb%8d" aria-label="1. Docker 介绍">1. Docker 介绍</a></li>
                    <li>
                        <a href="#2-docker-%e4%bd%bf%e7%94%a8%e5%9f%ba%e7%a1%80" aria-label="2. Docker 使用基础">2. Docker 使用基础</a><ul>
                            
                    <li>
                        <a href="#21-%e5%ae%89%e8%a3%85" aria-label="2.1 安装">2.1 安装</a></li>
                    <li>
                        <a href="#22-%e8%bf%90%e8%a1%8c%e5%ae%b9%e5%99%a8" aria-label="2.2 运行容器">2.2 运行容器</a></li>
                    <li>
                        <a href="#23-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%91%bd%e4%bb%a4" aria-label="2.3 客户端命令">2.3 客户端命令</a></li></ul>
                    </li>
                    <li>
                        <a href="#3-%e5%88%9b%e5%bb%ba%e9%95%9c%e5%83%8f" aria-label="3. 创建镜像">3. 创建镜像</a><ul>
                            
                    <li>
                        <a href="#31-dockerfile" aria-label="3.1 Dockerfile">3.1 Dockerfile</a></li>
                    <li>
                        <a href="#32-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f" aria-label="3.2 构建镜像">3.2 构建镜像</a></li>
                    <li>
                        <a href="#33-%e6%8e%a8%e9%80%81%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f" aria-label="3.3 推送、拉取镜像">3.3 推送、拉取镜像</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>


  <div class="post-content"><center><img src="docker-arch.webp" width="100%" /></center>
<h3 id="1-docker-介绍">1. Docker 介绍<a hidden class="anchor" aria-hidden="true" href="#1-docker-介绍">#</a></h3>
<p><em>“Docker is a platform designed to help developers build, share, and run container applications.”</em></p>
<p><strong>Docker daemon (dockerd)：</strong> Docker 守护进程，侦听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和卷。守护进程还可以与其他守护进程通信来管理 Docker 服务。</p>
<p><strong>Docker client (docker)：</strong> Docker 客户端，是许多 Docker 用户与 Docker 交互的主要方式。当使用诸如 docker run 命令时，client 会将这些命令发送到 dockerd，由后者执行这些命令。docker 命令使用的 Docker API。Docker 客户端可以与多个守护进程通信。</p>
<p><strong>Docker registries：</strong> Docker 仓库用于存储 Docker 镜像 (images)。Docker Hub 是任何人都可以使用的公共仓库，Docker 默认在 Docker Hub 上查找镜像。用户可以运行自己的私人仓库。当使用 docker pull 或 docker run 命令时，Docker 从配置的仓库中提取所需的镜像。当使用该 docker push 命令时，Docker 会将的镜像推送到配置的仓库。</p>
<p><strong>Docker objects：</strong> 使用 Docker 时 实际上是在创建和使用<em>镜像、容器、网络、存储卷、插件</em>等对象。</p>
<ul>
<li><strong>镜像（Image）</strong> 是用于创建 docker 容器的<em>模板程序</em>，包含了运行应用所需的所有东西 —— 包括代码、二进制脚本、依赖库、环境变量和配置文件等等。</li>
<li><strong>容器（Container）</strong> 是镜像的<em>运行实例</em>，它在隔离的环境中运行不与主机其他容器共享状态，可以使用 Docker API 创建、启动、停止、移动或删除容器，也可以将容器连接到一个或多个网络，为其附加存储，甚至可以根据其当前状态创建一个新的镜像。它与该宿主机上运行的所有其他进程隔离开来，这种隔离利用了内核名称空间和cgroups。</li>
<li><strong>存储</strong> 在 docker 中，存储是管理和持久化数据的关键组成部分。Docker 为数据存储和管理提供了几种机制，主要是通过卷（volumes）、绑定挂载（bind mounts）和临时文件系统（tmpfs mounts）。Docker提供了卷和绑定挂载两种选项（对应不同存储定义区），使得容器可以将文件存储在宿主机上，这样即使容器停止文件也会持久保存。docker 还支持容器将临时文件存储在宿主机的内存中，这类文件不会被持久保存。<center><img src="storage.webp" width="60%" /></center></li>
<li><strong>网络</strong> 容器网络指的是容器之间能够连接和通信，或者与非 docker 工作负载通信的能力。容器默认启用了网络功能可以建立外部连接，容器不知道自己连接到了什么类型的网络，只看到一个带有 IP 地址、网关、路由表、DNS 服务和其他网络详细信息的网络接口。Docker 提供了几种不同的网络驱动程序，每种驱动程序都支持不同的用例和网络操作模式，默认使用 bridge 类型驱动，它在没有指定网络的容器时会自动连接到本地主机上的一个私有内部网络。</li>
</ul>
<!-- more -->
<h3 id="2-docker-使用基础">2. Docker 使用基础<a hidden class="anchor" aria-hidden="true" href="#2-docker-使用基础">#</a></h3>
<h4 id="21-安装">2.1 安装<a hidden class="anchor" aria-hidden="true" href="#21-安装">#</a></h4>
<p>   以 CentOS 为例，安装、启动 docker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yum install -y yum-utils
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 docker 目标仓库并且从仓库安装</span>
</span></span><span class="line"><span class="cl">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</span></span><span class="line"><span class="cl">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 启动Docker服务并设置为开机启动</span>
</span></span><span class="line"><span class="cl">sudo systemctl start docker
</span></span><span class="line"><span class="cl">sudo systemctl <span class="nb">enable</span> docker
</span></span></code></pre></td></tr></table>
</div>
</div><p>   默认情况下，只有root用户和sudoer才可以运行Docker命令。为了避免每次都使用sudo，可以将用户添加到docker组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo usermod -aG docker <span class="si">${</span><span class="nv">USER</span><span class="si">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="22-运行容器">2.2 运行容器<a hidden class="anchor" aria-hidden="true" href="#22-运行容器">#</a></h4>
<p>   通过 docker run 可以运行已有镜像创建一个新的容器，并且在创建容器后会立即启动它。docker create 命令也可以创建容器但不启动，创建容器后可以使用 docker start 命令启动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run <span class="o">[</span>OPTIONS<span class="o">]</span> IMAGE<span class="o">[</span>:TAG<span class="p">|</span>@DIGEST<span class="o">]</span> <span class="o">[</span>COMMAND<span class="o">]</span> <span class="o">[</span>ARG...<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [OPTIONS] 是容器的相关配置信息</span>
</span></span><span class="line"><span class="cl"><span class="c1"># IMAGE[:TAG|@DIGEST] 是镜像标志名</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [COMMAND] [ARG...] 是设定容器启动后运行的命令</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>   常见的可选运行 [OPTIONS] 有</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">### 存储卷</span>
</span></span><span class="line"><span class="cl">--mount <span class="nv">source</span><span class="o">=</span>&lt;VOLUME_NAME&gt;,target<span class="o">=[</span>PATH<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">#绑定 Volume，source 是 volume name，target 是容器内的挂载路径</span>
</span></span><span class="line"><span class="cl">--mount <span class="nv">type</span><span class="o">=</span>bind,source<span class="o">=[</span>PATH<span class="o">]</span>,target<span class="o">=[</span>PATH<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 创建 Bind mounts，source 是 host 路径，target 是容器内的 bind 路径</span>
</span></span><span class="line"><span class="cl">-v/--volume host-src:container-dest<span class="o">[</span>:options<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Volume/Bind mounts 都可以用这个命令挂载，效果与上面相同</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">### 网络设置</span>
</span></span><span class="line"><span class="cl">--network NETWORK_NAME
</span></span><span class="line"><span class="cl"><span class="c1"># NETWORK_NAME 是事先用户创建的网络</span>
</span></span><span class="line"><span class="cl">--network container:&lt;name<span class="p">|</span>id&gt;
</span></span><span class="line"><span class="cl"><span class="c1"># 与另外一个 container 网络直连</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--publish/-p
</span></span><span class="line"><span class="cl">-p 192.168.1.100:8080:80
</span></span><span class="line"><span class="cl"><span class="c1"># 将主机 IP 192.168.1.100 的 8080 端口映射到 docker 的 80 端口</span>
</span></span><span class="line"><span class="cl">-p 8080:80/tcp -p 8080:80/udp
</span></span><span class="line"><span class="cl"><span class="c1"># 将 host 主机 的 8080 tcp/udp 端口映射到 docker 的 80 tcp/udp 端口</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">### 资源限制</span>
</span></span><span class="line"><span class="cl">-m/--memory<span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 内存限制</span>
</span></span><span class="line"><span class="cl">--memory-swap<span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 内存+swap限制</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--cpus<span class="o">=</span>0.000
</span></span><span class="line"><span class="cl"><span class="c1"># cpu 数目，0.000表示 不限制</span>
</span></span><span class="line"><span class="cl">--cpuset-cpus<span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 目标运行 cpu</span>
</span></span><span class="line"><span class="cl">--cpu-quota<span class="o">=</span>
</span></span><span class="line"><span class="cl">--cpu-period
</span></span><span class="line"><span class="cl"><span class="c1"># --cpu-quota 选项允许您指定容器可以获取的 CPU 时间周期的配额，与 --cpu-period 选项一起使用：例如 --cpu-quota 被设置为 50,000（微秒），并且 --cpu-period 是默认的 100,000（微秒），则表示该容器在每个 100 毫秒的 CPU 周期内能使用的 CPU 时间被限制在 50 毫秒内（cpu 利用率限制在 50%）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--blkio-weight
</span></span><span class="line"><span class="cl"><span class="c1"># 限制 direct io的贷款，是一个权重值，范围 10-1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--rm
</span></span><span class="line"><span class="cl"><span class="c1"># 在容器退出时自动清除容器的文件系统。不使用该参数时，容器的文件系统将保留在系统中，允许你稍后可以重新启动容器或检查其状态。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-d/--detach
</span></span><span class="line"><span class="cl"><span class="c1"># 直接分离，在后台运行容器</span>
</span></span><span class="line"><span class="cl">--detach-keys
</span></span><span class="line"><span class="cl"><span class="c1"># 参数允许重定义默认的热键，用于从容器的交互模式中分离出来，而不是用于终止容器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-w/--workdir
</span></span><span class="line"><span class="cl"><span class="c1"># 设置容器内的工作目录，当启动容器时，任何相对路径的命令或指令都将基于这个工作目录执行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-i/--interactive
</span></span><span class="line"><span class="cl"><span class="c1"># 保持 STDIN（标准输入）流开放，允许容器接收来自用户的输入</span>
</span></span><span class="line"><span class="cl">-t/--tty
</span></span><span class="line"><span class="cl"><span class="c1"># 为容器分配一个伪终端或 pseudo-TTY，模拟了终端设备，提供一个可以执行输入输出的文本界面</span>
</span></span><span class="line"><span class="cl">-it
</span></span><span class="line"><span class="cl"><span class="c1"># 结合使用 -it 参数时，允许与运行在容器中的命令行界面互动，就像是在使用一个交互式 shell 对话。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="23-客户端命令">2.3 客户端命令<a hidden class="anchor" aria-hidden="true" href="#23-客户端命令">#</a></h4>
<p>   docker 将默认配置文件保存在 /$HOME/.docker 下，运行时配置可以通过其中 config.json 文件进行配置。
   通过 <a href="https://docs.docker.com/reference/cli/docker/">docker 客户端命令</a>，可以管理容器的各种资源对象，其中一些客户端命令如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">#### 基本管理</span>
</span></span><span class="line"><span class="cl">docker info <span class="c1"># 查看当前版本、仓库等信息</span>
</span></span><span class="line"><span class="cl">docker login <span class="c1"># 登录 Docker 仓库进行认证，以允许拉取或推送镜像。</span>
</span></span><span class="line"><span class="cl">docker <span class="nb">logout</span> <span class="c1"># 从当前登录的仓库登出。</span>
</span></span><span class="line"><span class="cl">docker search <span class="c1"># 根据给定的条件在 Docker 仓库上搜索镜像。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#### 镜像管理</span>
</span></span><span class="line"><span class="cl">docker image <span class="c1"># 提供用于管理 Docker 镜像的子命令，如列出、删除和标记镜像。</span>
</span></span><span class="line"><span class="cl">docker builder <span class="c1"># 处理构建的生命周期。</span>
</span></span><span class="line"><span class="cl">docker buildx <span class="c1"># 扩展的构建命令，支持比如构建多架构镜像。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#### 容器管理</span>
</span></span><span class="line"><span class="cl">docker container <span class="c1"># 包含用于管理容器的子命令，包括创建、启动、停止、移动和删除容器。</span>
</span></span><span class="line"><span class="cl">docker checkpoint <span class="c1"># 管理检查点；检查点可以捕获正在运行的容器的状态。</span>
</span></span><span class="line"><span class="cl">docker <span class="nb">exec</span> <span class="c1"># 用于进入在已运行的容器内执行命令。</span>
</span></span><span class="line"><span class="cl">docker ps <span class="c1"># 列出所有容器，包括未运行的。</span>
</span></span><span class="line"><span class="cl">docker stop  <span class="c1"># 停止一个或多个正在运行的容器。</span>
</span></span><span class="line"><span class="cl">docker start  <span class="c1"># 启动一个或多个已停止的容器。</span>
</span></span><span class="line"><span class="cl">docker restart  <span class="c1"># 重新启动容器。</span>
</span></span><span class="line"><span class="cl">docker rm  <span class="c1"># 删除一个或多个容器。</span>
</span></span><span class="line"><span class="cl">docker logs <span class="c1"># 查看容器日志，dockerd的日志 linux 系统在 /var/log/messages 中</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">####其他管理</span>
</span></span><span class="line"><span class="cl">docker system <span class="c1"># 清理未使用的数据并显示 Docker 的系统范围内的信息。</span>
</span></span><span class="line"><span class="cl">docker inspect <span class="c1"># 查看 Docker 对象（容器，镜像，卷等）的低级信息。</span>
</span></span><span class="line"><span class="cl">docker init <span class="c1"># 为项目创建与 Docker 相关的启动文件，帮助快速设置。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#### 网络和卷管理</span>
</span></span><span class="line"><span class="cl">docker network <span class="c1"># 管理网络。</span>
</span></span><span class="line"><span class="cl">docker volume <span class="c1"># 管理卷。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#### Docker Swarm</span>
</span></span><span class="line"><span class="cl">docker service <span class="c1"># 管理 Docker 服务，是 Docker Swarm 缩放功能的基础单位。</span>
</span></span><span class="line"><span class="cl">docker node <span class="c1"># 管理 Docker Swarm 集群中的节点。</span>
</span></span><span class="line"><span class="cl">docker swarm <span class="c1"># 管理 Swarm，Docker 的本地编排和集群工具。</span>
</span></span><span class="line"><span class="cl">docker config <span class="c1"># 管理 Docker Swarm 配置，允许存储服务的配置文件。</span>
</span></span><span class="line"><span class="cl">docker context <span class="c1"># 管理上下文，允许 Docker 根据指定的上下文使用不同的配置。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-创建镜像">3. 创建镜像<a hidden class="anchor" aria-hidden="true" href="#3-创建镜像">#</a></h3>
<h4 id="31-dockerfile">3.1 Dockerfile<a hidden class="anchor" aria-hidden="true" href="#31-dockerfile">#</a></h4>
<p>   Dockerfile 是一个文本文件，里面包含了一系列的指令和参数，用于定义如何构建一个 Docker 镜像，在 <a href="https://docs.docker.com/reference/dockerfile/">Dockerfile</a> 中定义的每条指令将在构建过程中顺序执行，并每次形成一个layer。Dockerfile 的相关语法有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-docker" data-lang="docker"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s">	# 指定基础镜像（必需的指令，是构建自定义镜像的出发点）</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span>	<span class="c1"># 从构建上下文复制新文件或目录到容器中的路径。</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ADD</span>	<span class="c1"># 类似于 COPY，但还可以支持自动解压缩附加在 URL 上的存档文件</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span>	<span class="c1"># 定义在构建时可以传递给运行时的参数</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span>	<span class="c1"># 提供容器启动时的默认执行命令</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="c1"># 配置容器启动时运行的命令，允许该容器像程序一样被运行</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span>	<span class="c1"># 设置环境变量</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s">	# 告知 Docker 在容器运行时需要监听的端口</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">LABEL</span>	<span class="c1"># 添加元数据到镜像中，如描述、作者信息等</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ONBUILD</span>	<span class="c"># 添加在构建指定的派生镜像时被执行的触发指令</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span>	<span class="c1"># 运行指定的命令并创建镜像层，常用于安装软件包</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>SHELL	<span class="c1"># 设置镜像的默认 shell</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">STOPSIGNAL</span><span class="s"> # 设定退出镜像的 system call signal</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s">	# 设置 user 和 group ID</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">VOLUME</span><span class="s">	# 声明容器内的挂载点，主要用于持久化或共享数据</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s">	# 切换工作目录（路径）</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一个 Dockerfile 的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-docker" data-lang="docker"><span class="line"><span class="cl"><span class="c"># syntax=docker/dockerfile:1</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> ubuntu:22.04</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># install app dependencies</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> apt-get install -y python3 python3-pip<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> pip install <span class="nv">flask</span><span class="o">==</span>3.0.*<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># install app</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> hello.py /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># final configuration</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">FLASK_APP</span><span class="o">=</span>hello
</span></span><span class="line"><span class="cl"><span class="k">EXPOSE</span><span class="s"> 8000</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;flask&#34;</span><span class="p">,</span> <span class="s2">&#34;run&#34;</span><span class="p">,</span> <span class="s2">&#34;--host&#34;</span><span class="p">,</span> <span class="s2">&#34;0.0.0.0&#34;</span><span class="p">,</span> <span class="s2">&#34;--port&#34;</span><span class="p">,</span> <span class="s2">&#34;8000&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="32-构建镜像">3.2 构建镜像<a hidden class="anchor" aria-hidden="true" href="#32-构建镜像">#</a></h4>
<p>   通过 docker build 命令可以构建镜像，这个命令也等同于 docker image build、docker buildx build、docker builder build等命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-docker" data-lang="docker"><span class="line"><span class="cl">docker build <span class="o">[</span>OPTIONS<span class="o">]</span> PATH <span class="p">|</span> URL <span class="p">|</span> -<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>                       ^^^^context^^^^<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>   除了 Dockerfile 外，还有一个概念是 build “context”。Context 上下文是位于指定 PATH 或 URL 中的一组文件，构建过程可以引用上下文中的任何文件。例如，构建可以使用 COPY 指令来引用上下文中的文件。</p>
<p>   常见的可选构建 [OPTIONS] 有</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-t/--tag	<span class="c1"># 设置镜像 name 和可选的 tag，参数格式是 image_name:tag</span>
</span></span><span class="line"><span class="cl">-f/--file	<span class="c1"># Dockerfile 的名字，默认为当前路径下的 &#34;Dockerfile&#34;</span>
</span></span><span class="line"><span class="cl">--build-arg	<span class="c1"># build 时的环境变量，多个需要多组此参数 --build-arg VAR1=123</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="33-推送拉取镜像">3.3 推送、拉取镜像<a hidden class="anchor" aria-hidden="true" href="#33-推送拉取镜像">#</a></h4>
<p>   通过 docker login 可以登录到指定仓库，再通过 docker push 和 pull 推送或拉取指定镜像。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker login myregistry.com
</span></span><span class="line"><span class="cl">docker push myregistry.example.com/myimage:latest
</span></span><span class="line"><span class="cl">docker pull myregistry.example.com/myimage:latest
</span></span></code></pre></td></tr></table>
</div>
</div><p>Docker 默认使用 Docker Hub 作为仓库，如果想改变默认仓库，需要在 Docker 配置中设置 &ndash;registry-mirror 选项。通常通过编辑 Docker 守护进程的配置文件 daemon.json 来完成。文件的默认位置通常在 /etc/docker/daemon.json，修改其中的相关参数。更改配置后，需要重启 Docker 服务以使更改生效 <code>sudo systemctl restart docker</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;registry-mirrors&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;https://&lt;myregistry.example.com&gt;&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<!-- copyright -->
<div class="admonition">
  <div class="admonition-content">
    <ul>
      <li>版权声明：如需转载或引用，请附加本文链接并注明来源。</li>
    </ul>
  </div>
</div>
<!-- copyright -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mzyee.github.io/tags/docker/">docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mzyee.github.io/posts/mysql/mvcc/">
    <span class="title">« 上一页</span>
    <br>
    <span>InnoDB MVCC 逻辑学习</span>
  </a>
  <a class="next" href="https://mzyee.github.io/posts/mysql/lock/">
    <span class="title">下一页 »</span>
    <br>
    <span>MySQL 事务锁系统</span>
  </a>
</nav>

  </footer>
<div>
  <div class="pagination__title">
    <span class="pagination__title-h" style="font-size: 20px;">💬 评论</span>
    <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.staticfile.org/twikoo/1.6.25/twikoo.all.min.js"></script>
  <script>
    twikoo.init({
      envId: "https://mzyeee.netlify.app/.netlify/functions/twikoo",  
      el: "#tcomment",
      lang: 'zh-CN',
      region: 'ap-hongkong',
      path: window.TWIKOO_MAGIC_PATH || window.location.pathname,
    });
  </script>
</div>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://mzyee.github.io">MZY&#39;s Blog</a></span>
    <span>
        | Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>
    </span>
    <span id="busuanzi_container">
        | Viewer
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
